# Juno

Juno is your self-contained serverless platform for building full-stack web apps without DevOps or backend boilerplate. Developers use their favorite frontend frameworks like React, SvelteKit, or Next.js, and write backend logic in Rust or TypeScript as serverless functions. Everything is bundled into a single WebAssembly (WASM) artifact that runs in a decentralized, stateful environment â€” under full user ownership â€” on the Internet Computer. Juno cannot access or modify your code, data, or infrastructure. It supports GitHub Actions for deploys and upgrades, and provides both a CLI and web Console UI for managing projects. The local development environment closely mirrors production, ensuring smooth transitions from build to deployment â€” all with the privacy and control developers expect from self-hosting.

# Getting Started with Juno

Unless you're looking to solely host your static website, the recommended way to start with Juno is by developing locally using the emulator â€” a production-like environment with full support for data, authentication, storage, and serverless functions.

It gives you everything you need to build and test your app before deploying anything live.

Here are a few solid places to go from here:

*   ðŸš€ [Start a new project](/docs/start-a-new-project.md) â€“ Scaffold a brand new project with your favorite frontend framework.
*   ðŸ”Œ [Set up the SDK](/docs/setup-the-sdk.md) â€“ Integrate Juno into an existing app.
*   ðŸ§ª [Run your project locally](/docs/guides/local-development.md) â€“ Use the emulator to build and test locally in an environment that mirrors production.
*   ðŸ›°ï¸ [Deploy with a Satellite](/docs/create-a-satellite.md) â€“ When you're ready to go live, deploy your project to its own container.

---

## How It Works

Juno is your own self-contained execution space.

No DevOps. No backend boilerplate. No surprise complexity.

You build your frontend using the frameworks you love â€” React, SvelteKit, Next.js, you name it.

Need backend logic? Just drop in a serverless function written in Rust or TypeScript.

Everything gets bundled into a single deployable WebAssembly (WASM) container. One artifact. One push. That's your app. It runs in an unstoppable environment that holds its entire state â€” data, logic, and storage.

And here's the beauty of it: Juno controls nothing.

It has zero access to your code, data, or infrastructure. Everything runs under your ownership. Think of it as the space between self-hosting and the serverless cloud â€” a reimagined model for application development.

You manage your projects and supporting modules â€” themed around space mythology â€” using either a CLI or the Console UI, depending on your workflow.

To strengthen this principle of non-interference, deploys and upgrades can be handled via GitHub Actions if you choose to opt in â€” which themselves can't start or stop your app once it's live.

And during development, the environment mirrors production as closely as possible â€” so you're never caught by â€œbut it worked locally.â€

---

## Comparisons

Wondering how Juno stacks up in the real world? Compare it to today's most popular platforms:

*   [vs Vercel](/docs/comparison/vs-vercel.md)
*   [vs Netlify](/docs/comparison/vs-netlify.md)
*   [vs Railway](/docs/comparison/vs-railway.md)
*   [vs Heroku](/docs/comparison/vs-heroku.md)
*   [vs Self-Hosting](/docs/comparison/vs-self-hosting.md)

---

## Further Details

Learn more about the available products, from auth and data to hosting and functions.

*   [Authentication](/docs/build/authentication.md)
*   [Datastore](/docs/build/datastore.md)
*   [Storage](/docs/build/storage.md)
*   [Hosting](/docs/build/hosting.md)
*   [Functions](/docs/build/functions.md)
*   [Analytics](/docs/build/analytics.md)
*   [Monitoring](/docs/management/monitoring.md)
*   [Snapshots](/docs/management/snapshots.md)

# Start a New Project

With Juno, a project typically lives in a single repository â€” combining your frontend, serverless functions, and configuration. Whether you're starting from scratch or extending an existing app, the result is a full-stack project that deploys as a single container.

---

## ðŸ§­ Choose Your Starting Point

There are multiple ways to start a Juno project. Pick what fits best:

*   ([Use a Juno Template](#-scaffold-with-a-juno-template)) if you want everything preconfigured
*   ([Bring Your Own Framework](#-start-with-your-favorite-framework)) if youâ€™ve already picked a stack
*   ([Add Juno to an Existing Project](#-add-juno-to-an-existing-project)) for incremental adoption

---

## ðŸš€ Scaffold with a Juno Template

One way to get started is by scaffolding a full-stack project using our prebuilt templates â€” it sets up your frontend framework of choice along with serverless functions and emulator support.

To create a new project, just run:

*   npm
*   yarn
*   pnpm

```
npm create juno@latest
```

```
yarn create juno
```

```
pnpm create juno
```

**Note:**

Supports Astro, Next.js, React, SvelteKit, Vue, and Angular.

---

## âœ¨ Start with Your Favorite Framework

Prefer to begin with `npx create-next-app`, `npm create svelte@latest`, or any other starter you know well? Totally fine. Set up your frontend however you like, then bring in Juno afterward.

**SSR not supported:**

Juno doesnâ€™t yet support Server Side Rendering (SSR). Your frontend code should run on the client side. We recommend using Static Site Generation (SSG) or prerendering instead.

Once your app is ready, head over to the [SDK Setup Guide](/docs/setup-the-sdk.md) to:

*   Install the SDK
*   Enable emulator support
*   Add serverless functions
*   Configure deployment

This gives you full flexibility while keeping everything in one repo.

---

## ðŸ§© Add Juno to an Existing Project

Already have a project in development or production? You can integrate Juno incrementally.

Start with the [SDK Setup Guide](/docs/setup-the-sdk.md) and bring in only what you need â€” whether that's authentication, datastore, serverless functions, or all of the above.

---

## One Repo, One App

No matter how you start, Juno follows a simple principle: **one project = one repo = one container**.

Everything â€” frontend, backend, and app state â€” is bundled into a single WebAssembly (WASM) container and deployed together.

This architecture keeps development and deployment straightforward, reliable, and fully yours.

# Setup the SDK

To connect your app to a Satellite and use Juno's features â€” like authentication, data, storage, and serverless functions â€” you'll need to initialize the SDK.

This guide walks you through how to do that, whether you're using a plugin (Next.js, Vite) or setting things up manually.

**Info:**

If you intend to use Juno solely for **[hosting](/docs/build/hosting.md)** purposes, you may skip the following steps.

---

## TL;DR

1.  Call `initSatellite()` in your app code
2.  Create a `juno.config` file at the root to define your Satellite
3.  Connect code and config â€” preferably using the `@junobuild/nextjs-plugin` or `@junobuild/vite-plugin`

---

## Initialization

1.  Install the Juno SDK:

*   npm
*   yarn
*   pnpm

```
npm i @junobuild/core
```

```
yarn add @junobuild/core @icp-sdk/core @icp-sdk/auth @dfinity/utils
```

```
pnpm add @junobuild/core @icp-sdk/core @icp-sdk/auth @dfinity/utils
```

2.  Initialize your satellite in your web app:

```
import { initSatellite } from "@junobuild/core";await initSatellite();
```

It is generally recommended to initialize globally the library at the top of your application.

---

## Configuration

Juno uses a configuration file to determine which Satellite to connect to.

You can scaffold a minimal `juno.config` file using:

```
npx @junobuild/cli init --minimal
```

This creates a `juno.config` file â€” in TypeScript, JavaScript, or JSON depending on your preferences â€” at the root of your project. It contains metadata such as the Satellite ID used during SDK initialization.

---

## Connecting Code and Config

If you're using **Next.js** or **Vite**, we recommend installing the official plugin. It automatically loads values from your config file and injects them into your build as environment variables.

This means you can call `initSatellite()` without passing any parameters, the SDK will read them automatically from `process.env` or `import.meta.env`.

*   [Next.js Plugin](/docs/reference/plugins.md#nextjs-plugin)

next.config.js

```
import { withJuno } from "@junobuild/nextjs-plugin";// withJuno wraps your Next.js config and injects values from juno.configexport default withJuno();
```

*   [Vite Plugin](/docs/reference/plugins.md#vite-plugin)

vite.config.js

```
import juno from "@junobuild/vite-plugin";// Automatically injects values from juno.config for the buildexport default defineConfig({  plugins: [juno()]});
```

**Note:**

The templates already include both the config file and the plugin setup.

#### Not using a plugin?

You can also pass the Satellite ID manually to the SDK, though using the plugins is the preferred approach:

```
import { initSatellite } from "@junobuild/core";await initSatellite({  satelliteId: "your-actual-satellite-id"});
```

# Local Development

Juno offers something most platforms don't: a full local development environment that closely mirrors production.

## TL;DR

| What | How |
| --- | --- |
| Runtime supported | Docker or Podman |
| Start emulator | `juno emulator start` |
| Stop emulator | `juno emulator stop` |
| Console UI URL | [http://localhost:5866](http://localhost:5866) |

---

## What the Emulator Includes

When you develop locally, you're running an emulator that includes the well known infrastructure services â€” including the actual administration Console UI.

This enables:

*   A development experience that mirrors mainnet, helping you build with confidence
*   A smooth dev loop, from prototype to deployment
*   A unique way to build, debug, and validate smart contract logic and frontend behavior â€” all in one place

![A screenshot of the DEV Console UI login screen](/assets/images/login-c6e898b09eac53a54e6f2d2e2b27e03e.webp)

---

## Before you begin

The emulator is a self-contained local environment that runs in a container managed entirely by Juno â€” using either [Docker](https://www.docker.com/) or [Podman](https://podman.io/) under the hood.

Make sure your preferred runtime is installed on your machine:

*   [Docker: Windows](https://docs.docker.com/desktop/install/windows-install/)
*   [Docker: macOS](https://docs.docker.com/desktop/install/mac-install/)
*   [Docker: Linux](https://docs.docker.com/desktop/install/linux-install/)
*   [Podman: Installation guide](https://podman.io/getting-started/installation)

**Important:**

For MacBooks with M-series processors, if you aim to use **Docker**, it is important to install Docker Desktop **version 4.25.0 or later**, ideally the latest available version.

For **Podman**, we are not aware of any particular version requirements at this time.

---

## Getting Started

To run the emulator for local development, you need to have the Juno CLI installed.

If you haven't installed it yet, run:

*   npm
*   yarn
*   pnpm

```
npm i -g @junobuild/cli
```

```
yarn global add @junobuild/cli
```

```
pnpm add -g @junobuild/cli
```

Then, in your project folder, start the local emulator with:

```
juno emulator start
```

This will launch the emulator along with all the services needed to develop your project.

We recommend running this in a dedicated terminal window or tab, while your frontend project (e.g. using Vite or Next.js) runs separately using npm run dev or similar.

To stop the emulator, run:

```
juno emulator stop
```

**Note:**

While you could technically start the emulator using `docker run` or `podman run`, we recommend using the Juno CLI to manage the emulator lifecycle. It handles important checks, sets the correct configuration, and ensures everything runs as expected.

---

## Available Images

Juno provides two local environments. Most developers should start with **Skylab**, but Satellite is available for advanced or specialized workflows.

### ðŸ§ª Skylab: Full Local Stack (Recommended)

The `junobuild/skylab` image is the default and recommended environment. It mirrors the production stack and includes everything needed for end-to-end development.

Use it for the full experience, including the Console UI and supporting infrastructure.

### âš™ï¸ Satellite: Minimal Setup

The `junobuild/satellite` image is a lightweight alternative that runs a single Satellite. It skips the Console UI and supporting infrastructure.

Use it when you need a faster, minimal setup focused on CI pipelines or automated testing.

**Note:**

The default (auto-deployed) Satellite is available with a predefined canister ID `jx5yt-yyaaa-aaaal-abzbq-cai`.

### ðŸ“Š Feature Comparison

The table below shows which modules are available in each image and helps clarify what's included when running locally with Skylab or Satellite.

| Module | Skylab | Satellite |
| --- | --- | --- |
| Console (Backend) | âœ…   | âŒ   |
| Console (UI) | âœ…   | âŒ   |
| Create Satellites / Orbiters via Console UI | âœ…   | âŒ   |
| Default (auto-deployed) Satellite | âŒ   | âœ…   |
| Observatory | âœ…   | âŒ   |

Likewise, not all services are mounted by default - but they can be turned on (or off).

| Service | Skylab | Satellite |
| --- | --- | --- |
| Internet Identity | âœ…   | âœ…   |
| ICP Ledger | âœ…   | âœ…   |
| ICP Index | âœ…   | âœ…   |
| NNS Governance | âœ…   | âž–   |
| Cycles Minting (CMC) | âœ…   | âž–   |
| Cycles Ledger | âž–   | âž–   |
| Cycles Index | âž–   | âž–   |
| Registry | âž–   | âž–   |
| SNS | âž–   | âž–   |
| NNS-dapp | âž–   | âž–   |

---

## Console UI

When using the `junobuild/skylab` image, the Console UI becomes available by default at:

```
http://localhost:5866/
```

Once the emulator is running (`juno emulator start`), visit this URL in your browser to explore the Console â€” where you can create and manage Satellites, and explore features like Datastore, Authentication, Storage, and more.

---

## Hot Reload

The local container supports live reloading. When you modify your [configuration](/docs/reference/emulator/satellite.md#configuration) or build custom [Functions](/docs/build/functions.md) to enhance Juno's capabilities with serverless features, those changes will be automatically redeployed.

---

## Configuration Options

To customize the behavior of the local emulatorâ€”such as changing ports, setting a persistent volume name, or overriding the runner image â€” refer to the [Emulator Configuration](/docs/reference/configuration.md#emulator-configuration) section.

There you'll find detailed information about available options including:

*   âš™ï¸ Runner settings (e.g. image, platform, volume)
*   ðŸ”Œ Custom port mappings
*   ðŸ“ Shared folders and hot reloading
*   ðŸ§ª CI and test environment tips

---

## Usage

During local development - `npm run dev` - your app connects to the local emulator (container) by default â€” no extra configuration needed.

### Automatic Configuration (Recommended)

The recommended way to connect your app to the local container run in the emulator or any environment is by using the [plugins](/docs/reference/plugins.md).

They automatically resolve the Satellite ID and other environment variables and handle initialization for you.

### Manual Initialization

If you're not using a plugin and are initializing Juno manually, here's how to configure it to use the local container:

```
import { initSatellite } from "@junobuild/core";const container = import.meta.env.DEV === true;await initSatellite({  satelliteId: container    ? "jx5yt-yyaaa-aaaal-abzbq-cai"    : "aaaaa-bbbbb-ccccc-ddddd-cai",  container});
```

### Opt-out

The SDK automatically uses the emulator in local development. If you want to disable that behavior and connect directly to a remote canister (e.g. in CI or production testing), you can do:

```
await initSatellite({  satelliteId: "aaaaa-bbbbb-ccccc-ddddd-cai",  container: false});
```

---

## Administration

The admin server running on port `5999` provides a variety of internal management. Below are some tips and example scripts to make use of this little server.

### Get ICP

If you're using the full environment, the Console UI includes a "Get ICP" button in the wallet. It's a quick way to get ICP out of the box.

![A screenshot of the wallet with the Get ICP call to action of Console UI in dev mode](/assets/images/wallet-45c84f1968e0c6a2749b439aace1b0c1.webp)

You might want to transfer some ICP from the ledger to a specified principal, which can be particularly useful when you're just getting started developing your app and no users currently own ICP. This can be achieved by querying:

```
http://localhost:5999/ledger/transfer/?to=$PRINCIPAL
```

For example, you can use the following script:

```
#!/usr/bin/env bash# Check if a principal is passed as an argument; otherwise, prompt for itif [ -z "$1" ]; then  read -r -p "Enter the Wallet ID (owner account, principal): " PRINCIPALelse  PRINCIPAL=$1fi# Make a transfer request to the admin servercurl "http://localhost:5999/ledger/transfer/?to=$PRINCIPAL"
```

# Create a Satellite

When you're ready to deploy your project to production, you'll need to create a [satellite](/docs/terminology.md#satellite).

1.  To get started, sign-in to the Juno [console](https://console.juno.build). If you are a new developer on Juno and the Internet Computer, you may be prompted to create your first anonymous [Internet Identity](/docs/terminology.md#internet-identity).
2.  Click **Launch a new satellite**.
3.  Enter a name for your satellite (note: this is for display purposes only and does not need to be unique).
4.  Confirm with **Create a Satellite.**
5.  The platform will then create your satellite and provision its resources.
6.  Once the process is complete, click **Continue** to access the overview page.

ðŸŽ‰ Youâ€™re all set! You can now deploy your frontend app, static website, or publish your serverless functions to production.

âž¡ï¸ Continue with the [deployment](/docs/category/deployment.md) guides to take the next step.

# Development

Learn how to track page views, custom events, and performance metrics.

---

## Page views

Page views, such as when a visitor opens your website or navigates to a subpage, are automatically tracked once you have configured, initialized, and deployed your application with the analytics module.

There's **no need** for additional development work!

However, if you (really) want to trigger page view tracking manually, you can do so using the `trackPageView()` function provided by the SDK.

```
import { trackPageView, trackPageViewAsync } from "@junobuild/analytics";trackPageView(); // or await trackPageViewAsync();
```

---

## Track custom events

Custom events can be tracked using the `trackEvent` function. You need to provide a `name` for the event, and you can include up to 10 custom `metadata` fields.

**Note:**

This is an option. As explained in the previous chapter, the library will take care of gathering insightful anonymous data as soon as it is configured and initialized.

Custom events are useful if you want to take an extra step and collect your own specific information.

Here's an example of how to use it:

```
import { trackEvent, trackEventAsync } from "@junobuild/analytics";// Fire-and-forgettrackEvent({  name: "Your custom event",  metadata: {    your_key: "A value",    your_other_key: "Another value"  }});// Or await it if neededawait trackEvent({  name: "Your custom event",  metadata: {    your_key: "A value",    your_other_key: "Another value"  }});
```

Use the `async` version if you're tracking events for which you want to absolutely ensure delivery before continuing the flow â€” for example, before navigating away or submitting critical user input.

That said, the tracker sends data using `keepalive` fetch requests by default, so in most cases thereâ€™s no difference in reliability â€” the choice is mostly a matter of convenience and flow control.

**Important:**

For scalability and optimization reasons, the data collected must adhere to certain rules, particularly regarding their length. For instance, a randomly generated key should not exceed 36 bytes in length.

For detailed information about these rules, please refer to Juno's GitHub [repository](https://github.com/junobuild/juno).

---

## Campaign tracking with UTM parameters

Juno Analytics automatically supports [UTM parameters](https://en.wikipedia.org/wiki/UTM_parameters) out of the box. These are standard query parameters (like `utm_source`, `utm_medium`, and `utm_campaign`) commonly added to links in newsletters, ads, and social posts to help you understand how visitors reach your app.

They're added to the end of a URL as query parameters. For example:

```
?utm_source=newsletter&utm_medium=email&utm_campaign=rocket-launch
```

As long as your URLs include UTM tags, campaign data will be collected and shown in your dashboard â€” no additional setup needed.

### Common UTM parameters

| Parameter | Required | Description | Example |
| --- | --- | --- | --- |
| `utm_source` | âœ…   | Where the traffic comes from | `newsletter`, `twitter`, `github` |
| `utm_medium` |     | The channel used | `email`, `social` |
| `utm_campaign` |     | The name of the campaign | `rocket-launch` |
| `utm_term` |     | Keywords for paid search | `juno+analytics` |
| `utm_content` |     | Distinguish between different links | `header-button`, `footer-link` |

Only the `utm_source` field is mandatory. If it's missing, the campaign will not be tracked.

# Setup

This section covers how to integrate and configure Juno Analytics in your app or website.

---

## Getting Started

Before integrating Juno Analytics into your app or website, you need to create an Orbiter - the analytics container that collects anonymous usage data. Here's a step-by-step guide to get started:

1.  Sign in to the Juno [Console](https://console.juno.build)
2.  Navigate to [Analytics](https://console.juno.build/analytics/)
3.  Click on **Get started**
4.  Confirm by selecting **Create analytics**
5.  (Optional) In **Advanced Options**, choose a European subnet if you want your data stored in Europe
6.  Once the setup completes, click **Close** to exit the wizard

ðŸŽ‰ You've now created your Analytics Orbiter!

But you're not done yet â€” you still need to tell it which Satellites (apps) can send data.

ðŸ›  **Final Step: Setup Tracking**

Go to the [Setup](https://console.juno.build/analytics/?tab=setup) tab in the Analytics page and select which Satellites should be allowed to track page views and events.

---

## Setup

There are two ways to integrate Juno Analytics into your project:

1.  Using your favorite package manager (`npm`, `yarn`, `pnpm`). ([Learn how](#1-with-package-manager)).
    
2.  Without installation by fetching the library from a CDN. ([Learn how](#2-from-a-cdn)).
    

---

### 1\. With Package Manager

Follow these steps to install and initialize the SDK using your preferred package manager.

#### Install the Library

To install the analytics library, run the following command:

*   npm
*   yarn
*   pnpm

```
npm i @junobuild/analytics
```

```
yarn add @junobuild/analytics
```

```
pnpm add @junobuild/analytics
```

#### Configure

If you're using the [Next.js](/docs/reference/plugins.md#nextjs-plugin) or [Vite](/docs/reference/plugins.md#vite-plugin), you can define your configuration in your `juno.config` file.

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist"  },  orbiter: {    ids: {      production: "aaaa-bbbbb-ccccc-ddddd-cai" // <-- Replace with your ID    }  }});
```

If you're not using a plugin, you can skip this step and instead provide the IDs manually when initializing the Orbiter (see next section).

#### Initialize

âœ… Using plugins and config

Just call `initOrbiter()` as early as possible in your app startup:

```
import { initOrbiter } from "@junobuild/analytics";initOrbiter();
```

ðŸ›  Without plugins

Pass your Satellite and Orbiter IDs manually:

```
import { initOrbiter } from "@junobuild/analytics";initOrbiter({  satelliteId: "<SATELLITE_ID>", // replace with your Satellite ID  orbiterId: "<ORBITER_ID>" // replace with your Orbiter ID});
```

---

### 2\. From a CDN

If you don't want to - or cannot - install anything locally, you can load the SDK directly from a CDN.

Add the following script to your HTML (for example, in `index.html`). This will fetch the library from [jsDelivr](https://www.jsdelivr.com/) and start the analytics when someone loads your site:

```
<script type="module">  import { initOrbiter } from "https://cdn.jsdelivr.net/npm/@junobuild/analytics@0.2.0/+esm";  document.addEventListener(    "DOMContentLoaded",    () =>      initOrbiter({        satelliteId: "<SATELLITE_ID>", // replace with your Satellite ID        orbiterId: "<ORBITER_ID>" // replace with your Orbiter ID      }),    {      once: true    }  );</script>
```

---

## Optional Features

The SDK includes a few optional features you can enable to enrich your analytics. By default, these are disabled to keep your bundle small and your app fast.

---

### UA Parser

By default, the library uses a naive approach to analyze the user agent string â€” enough to detect general categories (like mobile vs desktop) â€” while keeping the bundle lean and fast.

If you need more detailed insights such as browser name, OS, or device model, you can opt in to use a full UA parser.

#### What It Adds

When enabled, the parser collects:

*   Browser name and version
*   Operating system
*   Device type (e.g., mobile, desktop, tablet)

These enrich the stats visible in the dashboard, including OS and better browser breakdowns.

#### Why It's Opt-In

*   Adds a few extra kilobytes to the app bundle
*   Disabled by default to preserve performance and minimize boot time

**Note:**

A more complete UA parsing approach could be performed inside a container, but this would currently require too many resources impacting both performance and cost. Delegating it to the frontend keeps things fast and efficient.

#### How to Enable

Pass `userAgentParser: true` when calling `initOrbiter()`:

```
import { initOrbiter } from "@junobuild/analytics";initOrbiter({  options: {    userAgentParser: true  }});
```

---

### Performance Metrics

Juno Analytics supports tracking key performance metrics using [Web Vitals](https://github.com/GoogleChrome/web-vitals). This feature is **opt-in** and requires configuration in both the Console and your app's code.

#### Key Metrics

When enabled, the following Web Vitals are tracked:

*   **Time to First Byte (TTFB)**: Measures the time it takes for the first byte of data to reach the user's browser, indicating server responsiveness.
*   **First Contentful Paint (FCP)**: Marks the time when the first piece of content is rendered, helping assess initial loading speed.
*   **Largest Contentful Paint (LCP)**: Tracks the time when the largest content element becomes visible, indicating when the main content is likely fully loaded.
*   **Cumulative Layout Shift (CLS)**: Quantifies unexpected layout shifts during loading, reflecting visual stability.
*   **Interaction to Next Paint (INP)**: Measures the latency of interactions, such as clicks, to evaluate application responsiveness.

#### How to Enable Web Vitals

To start collecting performance metrics, you need to enable it in two places:

1.  **In the Console**

Go to your Orbiter's [Setup tab](https://console.juno.build/analytics/?tab=setup) and click "Edit Configuration". Enable the "Web Vitals" option under the "Advance Options" to allow the Orbiter to store performance data.

2.  **In your App**

Enable Web Vitals in the SDK during initialization. This ensures that the additional logic is only loaded when needed, helping keep your app's initial load size minimal.

```
import { initOrbiter } from "@junobuild/analytics";initOrbiter({  options: {    performance: true  }});
```

---

## Best Practices

Here are some useful tips for working with the analytics.

### Production vs Development

While the example above shows analytics being initialized in all cases, it's recommended to **disable analytics during local development**. This prevents test data from polluting your metrics if your local environment is connected to production, and avoids errors when analytics aren't set up locally which is often the case during development.

```
if (DEV) {  return;}initOrbiter();
```

### Use Environment-Specific IDs

You can also configure different IDs for different environments (e.g., development and production):

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist"  },  orbiter: {    ids: {      production: "aaaa-bbbbb-ccccc-ddddd-cai",      development: "ffff-eeee-ddddd-ccccc-cai"    }  }});
```

# Google

Google Sign-In lets users authenticate with their existing Google account using OpenID Connect (OIDC) - a modern, secure identity standard built on top of OAuth 2.0.

This provides a fast and familiar experience for users, without you having to manage passwords or credentials directly.

It's the easiest way to onboard users who expect a simple, frictionless login flow that works across devices and browsers.

---

## How It Works

1.  The user signs in with Google.
2.  Google verifies their credentials and issues a signed OpenID Connect token.
3.  Your Satellite verifies the token and its signature, and extracts the user's information (such as email or profile).
4.  It then establishes a session for the user.

**Note:**

Google authentication is not domain-scoped. Users keep the same identity across all your apps each time you use the same Google Client ID.

---

## Configuration

To enable Google authentication for your project:

### 1\. Get your Google credentials

Start by creating your Google credentials.

It's best to use a separate Google Cloud project for each environment (development, staging, production) so you can keep configurations clean and secure.

1.  Go to the [Google Cloud Console](https://console.cloud.google.com/apis/dashboard).
2.  Create a new project (or select one for your current environment). You might need to switch to your newly created project after creating it.
3.  If you created a new project, configure the OAuth consent screen with information about your app. Click Configure consent screen when prompted.
4.  Open **APIs & Services â†’ Credentials**.
5.  Click **Create Credentials â†’ OAuth Client ID**.
6.  Select **Web application** as the application type.

Then, configure your redirect URIs.

For local development, you can use something like `http://localhost:3000/auth/callback/google`. In production, use the URL that matches your deployed app, for example `https://example.com/auth/callback/google`.

The exact redirect path depends on how your app handles authentication, but make sure you always set at least one redirect URI in your Google Console.

**Caution:**

Creating a separate OAuth 2.0 Client ID for each environment and always configuring **Authorized redirect URIs** is a must.

Since the Client ID is public, leaving redirect URIs open could let attackers interfere with your authentication flow. Likewise, keeping a localhost URL alongside your production redirect is also a security risk.

It's also recommended to set Authorized JavaScript origins, which will be used once FedCM (Federated Credential Management) support is added.

### 2\. Configure the provider

Once your credentials are ready, you need to add your Google Client ID to your project configuration.

In your `juno.config` file:

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      development: "<DEV_SATELLITE_ID>",      production: "<PROD_SATELLITE_ID>"    },    source: "dist",    authentication: {      google: {        clientId: "1234567890-abcde12345fghijklmno.apps.googleusercontent.com"      }    }  }});
```

If you use different Client IDs for each environment (as recommended), you can leverage the build mode to load configuration conditionally.

For example, to enable Google Sign-In only in production:

```
import { defineConfig } from "@junobuild/config";export default defineConfig(({ mode }) => ({  satellite: {    ids: {      development: "<DEV_SATELLITE_ID>",      production: "<PROD_SATELLITE_ID>"    },    source: "dist",    ...(mode === "production" && {      authentication: {        google: {          clientId: "1234567890-abcde12345fghijklmno.apps.googleusercontent.com"        }      }    })  }}));
```

### 3\. Apply the configuration

Once your credentials are set in `juno.config`, you need to make sure both your frontend and your Satellite are using the correct and same Google Client ID.

#### Frontend

The frontend, your application, needs the Client ID to start the sign-in flow.

If you are using the Juno Vite or Next.js plugin, the configuration is read automatically from `juno.config`, so you do not need to do anything. The Client ID is injected at build time.

If you are not using a plugin, you need to pass the Client ID manually, either from your environment variables or directly in the sign-in call (see ([Options](#options))).

#### Backend

Your Satellite also needs the Client ID because it is used to validate the JWT tokens issued during the sign-in flow with the third party provider in this case Google.

You can configure this in two ways:

*   **Through the Console:**

Go to [console.juno.build](https://console.juno.build), select your Satellite, then open **Authentication â†’ Setup** and enable **Google**.

The wizard will ask for your Client ID and enable the provider.

*   **Through the CLI:**

If you already have the CLI installed and since the Client ID has been defined in your `juno.config`, you can apply the configuration directly with:

```
juno config apply
```

By default, this applies the production configuration. You can specify another mode using `--mode` argument if needed.

---

## Sign-In

Once your configuration is ready, you can let users sign in with their Google account.

```
import { signIn } from "@junobuild/core";await signIn({  google: {}});
```

This starts the standard Google redirect flow.

After the user authenticates, they should be redirected to the URL you configured as an Authorized redirect URI in the Google Cloud Console.

You can pass this URL through the `redirectUrl` option. If you omit it, the current origin (`window.location.origin`) is used.

### Options

Google sign-in supports a few options that let you control scopes, redirect URLs, and the overall sign-in experience.

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| `clientId` | `string` | from `juno.config` | Your Google OAuth Client ID. If not provided, it is automatically read from your project configuration using the plugins. |
| `redirectUrl` | `string` | `window.location.origin` | The URL where the user is redirected after sign-in. It must match one of your authorized redirect URIs in the Google Cloud Console. |
| `authScopes` | `GoogleAuthScopes` | `['openid', 'profile', 'email']` | OAuth scopes to request. Must include `openid` and at least one of `profile` or `email`. |
| `loginHint` | `string` |     | Optional hint such as an email address that tells Google which user is likely signing in. Helps skip the account picker for known users. |

Example:

```
import { signIn } from "@junobuild/core";await signIn({  google: {    redirect: {      clientId: "1234567890-abcde12345fghijklmno.apps.googleusercontent.com",      authScopes: ["openid", "email"],      redirectUrl: "https://example.com/auth/callback/google",      loginHint: "user@example.com"    }  }});
```

---

## Handling the Redirect

After authentication, Google redirects the user back to your app with a signed token. You must handle that redirect on the route that matches your configured `redirectUrl`. For example, `/auth/callback/google`.

```
import { handleRedirectCallback } from "@junobuild/core";await handleRedirectCallback();
```

If the callback is successful, the user is signed in and a session is created.

**Tip:**

After handling the redirect, it's best to navigate elsewhere in your app without keeping browser history. This prevents the user from re-triggering authentication when pressing the back button.

---

## Advanced Configuration

You can optionally configure how authentication sessions behave on your Satellite.

These settings can be defined in your `juno.config` file and applied with `juno config apply` or adjusted directly in the Console under **Authentication â†’ Setup**.

### Delegation

The `delegation` section defines how long sessions last and which modules authenticated users are allowed to call using their active session.

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| `allowedTargets` | `PrincipalText[]` or `null` | restricted to this Satellite | List of modules (canisters on the Internet Computer) that authenticated users may call. Omit to restrict access to this Satellite only. Provide an array to allow calls only to specific targets. Set to `null` to allow calls to **any** backend (**use with caution**). |
| `sessionDuration` | `bigint` | 1 day | How long a user session remains valid, expressed in **nanoseconds**. Cannot exceed 30 days. Applies only to new sessions. |

Example configuration:

```
authentication: {  google: {    clientId: "1234567890-abcde12345fghijklmno.apps.googleusercontent.com"  },  delegation: {    allowedTargets: ["<YOUR_SATELLITE_ID>", "<LEDGER_CANISTER_ID>"],    sessionDuration: BigInt(7 * 24 * 60 * 60 * 1_000_000_000) // 7 days  }}
```

---

## Recommendations

*   âš ï¸ Always configure **Authorized redirect URIs** in the Google Cloud Console.
*   Use a separate **OAuth Client ID** for each environment (development, staging, production).
*   Keep your frontend and Satellite **Client IDs** in sync.
*   Do not leave a **localhost URI** next to production URIs in the same Client ID.
*   In the future, Juno will support **FedCM (Federated Credential Management)** for Google Sign-In without redirects.

---

---

## Infrastructure Overview

When you enable Google Sign-In, authentication involves two systems: Google and your Satellite.

Google handles the user-facing part â€” displaying the sign-in screen and issuing a signed OpenID Connect (OIDC) token once the user authenticates.

From there, everything else runs within your Satellite container:

*   The Satellite verifies the token's signature.
*   It prepares and signs a delegation identity that represents the authenticated user session.
*   It creates (or retrieves) the user entry that your app can then use with Juno services such as [Datastore](/docs/build/datastore.md) and [Storage](/docs/build/storage.md).

### Token Verification

OIDC tokens are signed by Google using rotating public keys (JWKS). Therefore, to verify these signatures, Satellites need access to those keys.

Instead of having each Satellite perform HTTPS outcalls to Google â€” which would add cost and subnet load â€” Juno provides these keys through a shared infrastructure module called [Observatory](/docs/miscellaneous/architecture.md#observatory).

Observatory regularly fetches and caches Google's public keys, ensuring that verification inside your Satellite remains fast and reliable without introducing additional overhead.

This setup means your Satellite **trusts Juno** to deliver the correct, untempered, up-to-date keys.

If you prefer to control this part as well, or if you want to improve redundancy in your setup while taking care of the related cost, you can spin your own Observatory instance. Reach out if you're interested in setting that up.

# Internet Identity

[Internet Identity](https://identity.ic0.app) lets users authenticate securely and anonymously through a decentralized identity system built for the Internet Computer.

When a user signs in with Internet Identity, they confirm their identity through the provider. If successful, a session is created automatically and the user can interact with your satellite.

Authentication with Internet Identity offers strong privacy guarantees and complete isolation between domains by design.

---

## How It Works

1.  The user signs in via Internet Identity.
2.  The provider issues a unique, domain-specific pseudonymous identity.
3.  Your project associates that identity with the user's data in your Satellite.
4.  The user can immediately start using your app - no email, passwords, or extra setup.

---

---

## Example

```
import { signIn } from "@junobuild/core";await signIn({  internet_identity: {}});
```

This creates (or reuses) a session automatically the first time the user signs in.

---

## Options

Internet Identity sign-in can be customized with options that let you control session lifetime, provider configuration, or track progress during the flow.

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| `maxTimeToLiveInNanoseconds` | `BigInt(4 * 60 * 60 * 1000 * 1000 * 1000)` | **4 hours** | Maximum lifetime of the user's session in **nanoseconds**. Once expired, the session cannot be extended. |
| `windowed` | `boolean` | `true` | By default, the authentication flow is presented in a popup window on desktop that is automatically centered on the browser. This behavior can be turned off by setting the option to `false`, causing the authentication flow to happen in a separate tab instead. |
| `derivationOrigin` | `string` or `URL` |     | The main domain to be used to ensure your users are identified with the same public ID, regardless of which of your satellite's URLs they use to access your application. |
| `onProgress` | `(progress) => void` |     | Callback for provider sign-in and user creation/loading. |
| `domain` | `internetcomputer.org` or `ic0.app` or `id.ai` | `internetcomputer.org` | The domain on which to open Internet Identity. |

Example with options:

```
// Sign-in with id.aiawait signIn({  internet_identity: {    options: {      domain: "id.ai"    }  }});// Sign-in with a specific session durationawait signIn({  internet_identity: {    options: {      maxTimeToLiveInNanoseconds: BigInt(24 * 60 * 60 * 1000 * 1000 * 1000) // 1 day    }  }});// Sign-in with a derivation origin and progression callbackawait signIn({  internet_identity: {    options: {      onProgress: ({ step, state }) => {        console.log("Step:", step, "State:", state);      },      derivationOrigin: "https://myapp.com"    }  }});
```

---

## Context

In addition to the options above, some settings apply to flow itself.

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| `windowGuard` | `boolean` | `true` | Prevents the user from closing the current window/tab while the flow is in progress. Disabling it is discouraged. |

---

## Handling Errors

If the sign-in flow encounters an error, an exception will be thrown.

When a user cancels sign-in with Internet Identity (e.g., by closing the modal), the library throws a `SignInUserInterruptError`. This error indicates that the user intentionally interrupted the sign-in process, and it's generally best practice to ignore it rather than showing an error message.

```
import { signIn } from "@junobuild/core";try {  await signIn({    internet_identity: {}  });} catch (error: unknown) {  if (error instanceof SignInUserInterruptError) {    // User canceled sign-in, no need to show an error    return;  }  // Handle other errors  console.error("Sign-in failed:", error);}
```

---

## Domain-Based Identity

With Internet Identity, a user's identity is created separately for each domain.

If a user signs in on two different domains, they will be treated as two separate users by default. The same applies to subdomains: signing in on `hello.com` and `www.hello.com` creates two different identities unless you configure a primary domain.

The first custom domain you add in the Console is automatically set as the primary domain. You can change this setting later in Authentication, but we don't recommend it once users have already registered, since their identities are not migrated when the configuration changes.

To let users keep the same identity across domains, you must also configure your frontend app to specify the main domain at sign-in. This is known as the "derivation origin" (or "alternative origins").

### Recommendation

If you're unsure which domain to use as the primary domain, here are two common approaches:

*   **Use your custom domain** (e.g. `mydomain.com`) if you're confident it will remain the main entry point for users. This ensures a consistent user experience - users will always see and recognize the same URL when signing in.
    
*   Alternatively, stick with **the default domain** (`{satellite-id}.icp0.io`) if:
    
    *   You're still experimenting with your domain setup and might change it later.
    *   You're not ready to commit to a long-term domain.
    *   You plan to host multiple satellites under different domains and don't want to tie user identity to just one.

Choosing the right derivation origin early helps avoid identity issues later, but both approaches are valid depending on your goals.

# Management

This page provides an overview of the administrative functions available in the Juno Console related to user management.

---

## Banning Users

The built-in authentication feature allows developers to ban or unban users within their dapps. When a user is banned, they lose access to key services such as Datastore and Storage, preventing them from creating, updating, or deleting any data. This feature helps developers prevent misuse, spam, or abusive behavior in their applications.

**Note:**

A ban is not a deletion. The user's authentication entry remains in the system, and they can be unbanned at any time.

### How to Ban a User

To ban a user, follow these steps:

*   Navigate to the Authentication section in the [console](https://console.juno.build).
*   Find the user you want to ban in the users' table.
*   Click on the Active / Ban button at the start of the row.
*   Confirm the action.

Once banned, the user will not be able to sign in, create, update, or delete data in Datastore or Storage.

![A screenshot of the Juno Console&#39;s Authentication section, displaying the user management interface with options to ban or unban users](/assets/images/user-management-ban-90535848bf31b97659d5fecd4e4d54f1.webp)

---

## Setup

The Authentication tab in the Console (or the CLI config) lets you customize how users sign in to your app and who's allowed to access it. Here are the available options:

---

### Main Domain ("Derivation Origin")

This setting helps you control how users are identified when signing in with Internet Identity. It makes sure users get the same identity across different domains or subdomains of your app.

For example, if you set it to "hello.com", a user signing in at [https://hello.com](https://hello.com) will receive the same identifier (principal) as when signing in at [https://www.hello.com](https://www.hello.com). In other words, the user will be recognized as the same person.

This is useful because, by design, it creates a different identity for each domain to protect user privacy and prevent tracking.

Use this if your app runs on multiple subdomains and you want a consistent user experience.

---

### Max Updates Per Minute

This lets you limit how many new users can sign up per minute. It's helpful to prevent abuse or unexpected spikes (like bots flooding your app).

For example, setting this to `10` means only `10` new users can be created per minute.

Default is `100`.

---

### Allowed Callers

This option gives you full control over who's allowed to use your app.

If you enable this, only the identities you list (in user key, format, like `bj4r4-5cdop-...`) will be allowed to sign in or use any features like Datastore or Storage.

*   If someone's not on the list, they can't even register.
*   If they are, they can use the app just like any other user (unless they're banned).

Use this if you want to limit access to a private group â€” for example, for internal testing or early access users.

#### How to Get the User Identities

There are two common ways to manage the list of authorized users:

1.  After sign-in

You can share your app link with a few users, let them sign in, and then add their keys to the authorized list. The user table will show their identity once they've signed in at least once.

2.  Before sign-in

If you want to block all sign-ins except for those explicitly allowed before hand, start by adding your own developer ID (shown in the Console) to the list.

This activates the restriction: once at least one identity is listed, only those identities can sign in. If the list is empty, then everyone can sign in.

You can then share the app link with others. When they attempt to sign in and are blocked, you can show a message that displays their user key (e.g. using the `unsafeIdentity` function from `@junobuild/core`).

They can send you their key, and you can add them to the list manually to grant access.

# Passkeys

Passkeys let your users authenticate without passwords - using their device's built-in security features such as Face ID, Touch ID, or device unlock.

They are built on WebAuthn, providing strong cryptographic security while offering a frictionless, Web2-like user experience.

When users sign in with a passkey, their private key never leaves the device. Your Satellite uses only a cryptographic signature to confirm their identity, ensuring authentication is secure and privacy-preserving by default.

---

## How It Works

1.  When a user signs up, your project creates a passkey on their device that's tied to your domain.
2.  The passkey is stored securely by the device or its manager (e.g. iCloud Keychain, Google Password Manager).
3.  On sign-in, the user proves ownership of the passkey by signing twice with their device's authenticator.
4.  The identity is verified on the frontend through these signatures, and the resulting public key (the user's identity) is stored in your Satellite.
5.  Whenever the user interacts with your app, the Satellite checks that the caller's public key matches the stored one, ensuring the request comes from the legitimate user.

**Note:**

Passkeys are **domain-scoped**: a passkey created on `hello.com` will work on its subdomains (like `www.hello.com`), but not on different domains (like `world.com`).

You can change this behavior during setup if you want to use a higher-level domain as the passkey origin, but not a completely different one.

---

## Sign-up

With Passkeys, your users need to sign up to create an identity that grants them access to your application.

During this process, the user will be asked to use their authenticator twice: once to generate the passkey, and once more to sign their new identity which is then used to interact securely with your satellite.

```
import { signUp } from "@junobuild/core";await signUp({  webauthn: {}});
```

**Note:**

Returning users don't need to go through sign-up again. They can simply use ([sign-in](#passkeys-1)) with their existing passkey to authenticate.

### Options

Passkey sign-up can be customized with a handful of options. These let you control how long a session lasts, how the passkey is displayed to the user, and whether you want to track progress in your own UI.

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| `maxTimeToLiveInMilliseconds` | `number` | **4 hours** | Maximum lifetime of the user's session in **milliseconds**. Once expired, the session cannot be extended. |
| `onProgress` | `(progress) => void` |     | Callback fired at each step of the sign-up flow (e.g., creating credential, validating, signing). Useful if you want to show progress indicators in your UI. |
| `passkey` | `CreatePasskeyOptions` |     | Options for how the passkey should be created. |

The `passkey` option accepts the following fields:

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| `appId.id` | `string` | Current URL `hostname` | Domain your passkeys are tied to (e.g., `example.com` or `login.example.com`). Subdomains are supported. |
| `user.displayName` | `string` | `document.title` | Friendly name for the account (e.g., `"Maria Sanchez"`). Helps the user recognize which passkey belongs to them. |
| `user.name` | `string` | `displayName` | User-recognizable account identifier (e.g., email, username, or phone number). Distinguishes between accounts. |

Example with options:

```
import { signUp } from "@junobuild/core";await signUp({  webauthn: {    options: {      maxTimeToLiveInMilliseconds: 1000 * 60 * 60, // 1 hour      onProgress: ({ step, state }) => {        console.log("Step:", step, "State:", state);      },      passkey: {        displayName: "My Cool App" // or user input      }    }  }});
```

**Tip:**

It's common to let the user choose a nickname during sign-up.

This nickname can be passed as the `displayName` in the `passkey` option so the passkey is easy to recognize the next time they sign in (e.g. in iCloud Keychain or Google Password Manager).

---

## Sign-in

Returning users sign in using the digital key previously created on their device â€” for example in the browser, iCloud Keychain, Google Password Manager, etc.

The user will be asked to use their authenticator to prove possession of the passkey and re-establish a valid session with your satellite.

```
import { signIn } from "@junobuild/core";await signIn({  webauthn: {}});
```

**Note:**

New users must first go through ([sign-up](#passkeys)) to create a passkey before they can sign in.

### Options

Passkey sign-in can also be customized with options similar to sign-up. These let you control how long a session lasts and whether you want to track progress in your own UI.

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| `maxTimeToLiveInMilliseconds` | `number` | **4 hours** | Maximum lifetime of the user's session in **milliseconds**. Once expired, the session cannot be extended. |
| `onProgress` | `(progress) => void` |     | Callback fired at each step of the sign-up flow (e.g., fetching credential, validating, signing). Useful to customize your UI. |

Example with options:

```
import { signIn } from "@junobuild/core";await signIn({  webauthn: {    options: {      maxTimeToLiveInMilliseconds: 1000 * 60 * 60, // 1 hour      onProgress: ({ step, state }) => {        console.log("Step:", step, "State:", state);      }    }  }});
```

---

## Context

In addition to the options above, some settings apply to both sign-up and sign-in flows themselves.

| Option | Type | Default | Description |
| --- | --- | --- | --- |
| `windowGuard` | `boolean` | `true` | Prevents the user from closing the current window/tab while the flow is in progress. Disabling it is discouraged. |

---

## Checking Availability

Not every browser or device supports Passkeys. You can check availability before showing a sign-up or sign-in button with:

```
import { isWebAuthnAvailable } from "@junobuild/core";if (await isWebAuthnAvailable()) {  // Show Passkey sign-up option}
```

---

## Recommendations

*   Passkeys work best for users who expect a simple, device-native login experience.
*   Always check for WebAuthn support before showing a Passkey option.
*   Combine Passkeys with other providers (like [Google](/docs/build/authentication/google.md) or [Internet Identity](/docs/build/authentication/internet-identity.md)) to cover both mainstream and decentralized use cases.
*   Avoid changing your app's domain setup after users have registered, as identities are tied to the original domain scope.

# Authentication Utilities

These utilities work with **any authentication provider**.

They let you manage user sessions, react to authentication changes, and access identities for advanced use cases.

---

## Sign-out

You can end a user's session, no matter which provider they used to sign in, by logging them out.

```
import { signOut } from "@junobuild/core";await signOut();
```

By default, the page will automatically reload after a successful sign-out. This is a common pattern in logout flows that ensures the application restarts from a clean state.

If you wish to opt out, the library does clear its internal state and authentication before the reload, and you can use the `windowReload` option set to `false`.

```
import { signOut } from "@junobuild/core";await signOut({ windowReload: false });
```

---

## Listening to Auth Changes

You can monitor when a user signs in or out using `onAuthStateChange`. It gives you the current user and notifies you whenever their authentication state changes.

```
import { onAuthStateChange } from "@junobuild/core";// Reactively track if the user is signed in or signed outonAuthStateChange((user: User | null) => {  console.log("User:", user);});
```

If you register the subscriber at the top of your application, it will automatically reflect the user's state:

*   `null` when the app first loads and the user is not signed in
*   A `User` object when they sign in or refresh while authenticated
*   `null` again when they sign out

To stop listening, you can call the unsubscribe function returned:

```
import { onAuthStateChange } from "@junobuild/core";const unsubscribe = onAuthStateChange((user: User | null) => {  console.log("User:", user);});// Stop listeningunsubscribe();
```

---

## Imperative Access to Identity

For advanced use cases, you may need direct access to the user's identity. You can use `getIdentityOnce` to retrieve the identity if the user is currently authenticated.

**Caution:**

Use this function **imperatively only**. Do **not** persist the identity in global state or store it for reuse. This function is intended for short-lived, one-time operations only.

```
import { getIdentityOnce } from "@junobuild/core";// Returns null if the user is not authenticatedconst identity = await getIdentityOnce();if (identity !== null) {  // Use the identity to perform calls on the Internet Computer}
```

Typical use case for this function is to enable developers to implement custom features for the Internet Computer:

*   Passing the identity to temporarily create an actor or agent to call a canister
*   Signing a message or making a one-time authenticated call

---

## Session Expiration

To proactively detect when a session duration expires, you can use the pre-bundled Web Worker provided by Juno's SDK.

To do so, you can follow these steps:

1.  Copy the worker file provided by Juno's SDK to your app's static folder. For example, to your `public` folder with a NPM `postinstall` script:

```
{  "scripts": {    "postinstall": "node -e \"require('fs').cpSync('node_modules/@junobuild/core/dist/workers/', './static/workers', {recursive: true});\""  }}
```

Once configured, run `npm run postinstall` manually to trigger the initial copy. Every time you run `npm ci`, the post-install target will execute, ensuring the worker is copied.

2.  Enable the option when you initialize Juno:

```
import { initSatellite } from "@junobuild/core";await initSatellite({  workers: {    auth: true  }});
```

The `auth` option can accept either `true`, which will default to using a worker located at [https://yourapp/workers/auth.worker.js](https://yourapp/workers/auth.worker.js), or a custom `string` to provide your own URL.

When the session expires, it will automatically be terminated with a standard [sign-out](/docs/build/authentication/utilities.md#sign-out). Additionally, an event called `junoSignOutAuthTimer` will be thrown at the `document` level. This event can be used, for example, to display a warning to your users or if you wish to reload the window.

```
document.addEventListener(  "junoSignOutAuthTimer",  () => {    // Display an information to your users  },  { passive: true });
```

The worker also emits an event named `junoDelegationRemainingTime`, which provides the remaining duration in milliseconds of the authentication delegation. This can be useful if you want to display to your users how much time remains in their active session.

```
document.addEventListener(  "junoDelegationRemainingTime",  ({ detail: remainingTime }) => {    // Display the remaining session duration to your users  },  { passive: true });
```

# Collections

You can create or update a collection in the "Collections" tab in Juno's console under the [datastore](https://console.juno.build/datastore) view.

---

## Configuration

Each collection has a set of configurable options that define its behavior and limitations:

| Option | Mandatory | Description |
| --- | --- | --- |
| Key | Yes | A unique identifier for the collection. The key that you will use in your code to interact with a particular collection. |
| Read permission | Yes | Defines who can read documents in the collection. See ([Permissions](#permissions)) below. |
| Write permission | Yes | Defines who can create, update, or delete documents. See ([Permissions](#permissions)) below. |
| Memory | Yes | Specifies whether the collection uses `heap` or `stable` memory. This setting is permanent and cannot be changed after creation. The default is `stable` memory. For more information, see the related [documentation](/docs/miscellaneous/memory.md). |
| Max changes per user | No  | Limits the number of documents a single user can create, update, or delete in the collection. This helps maintain fair resource distribution across users. |
| Max capacity | No  | The maximum number of documents that can be stored in the collection, applying to the entire collection regardless of individual users. |
| Max updates per minute | No  | Limits the number of creation, update and delete operations per minute to prevent excessive updates. |
| Immutable permissions | No  | If enabled, read and write permissions cannot be modified after creation. |

---

## Permissions

Permissions define who can read and write documents in a collection. Writing includes creating, updating, and deleting documents.

| Permission | Description |
| --- | --- |
| **Public** | Anyone can read or write documents in the collection. |
| **Private** | Only the creator (owner) of a document can read or write to it. However, note that since satellite administrators manage the underlying infrastructure, they have the technical ability to modify access rules by changing its source code. |
| **Managed** | The owner of a document, the administrator and editor of the satellite can read or write to it in the collection. |
| **Restricted** | Only satellite administrator and editor can read or write any document in the collection. |

If not set to immutable, you can modify the permissions at any time, and the changes will take effect immediately.

**Tip:**

Any collection with read permissions set to `public`, `managed` or `restricted` will allow the developer to view its content in the console under the [datastore](https://console.juno.build/datastore) view.

# Development

This page provides an overview of how to integrate and manage documents using the Juno SDK, including adding, retrieving, updating, listing, and deleting documents within your app.

**Important:**

The functions described on this page are intended for use in the **client-side** of your app.

If you're looking to extend backend capabilities using serverless logic, refer to the [Functions documentation](/docs/build/functions.md).

---

## Add a document

To add a document, use the `setDoc` function:

```
import { setDoc } from "@junobuild/core";await setDoc({  collection: "my_collection_key",  doc: {    key: "my_document_key",    data: myExample  }});
```

You need to provide the `collection` in which to save the data and the `key` to use as an index for the document. The `data` can be any [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description)\-serializable data.

### Key

The `key` can be any `string`, but it's recommended to generate IDs using the [nanoid](https://github.com/ai/nanoid) library.

```
import { setDoc } from "@junobuild/core";import { nanoid } from "nanoid";const myId = nanoid();await setDoc({  collection: "my_collection_key",  doc: {    key: myId,    data: myExample  }});
```

### Description

A document can be saved with an optional `description` field, allowing for a maximum length of 1024 characters. This field serves both descriptive purposes and can be used for more granular filtering of your documentation. When retrieving documents, you can also filter based on the description field in addition to the keys, providing additional flexibility and organization options.

```
import { setDoc } from "@junobuild/core";await setDoc({  collection: "my_collection_key",  doc: {    key: "my_document_key_1",    data: myExample,    description: "This is a description"  }});await setDoc({  collection: "my_collection_key",  doc: {    key: "my_document_key_2",    data: myExample,    description: "#programming #technology #web3 #junobuild"  }});
```

---

## Get a document

To retrieve data, use the `getDoc` function and provide the `collection` and the `key` of the document:

```
import { getDoc } from "@junobuild/core";const myDoc = await getDoc({  collection: "my_collection_key",  key: myId});
```

---

## Get multiple documents

Obtaining multiple documents at once can improve performance compared to making multiple individual `getDoc` calls depending on the use case.

You can achieve this by using the `getManyDocs` function:

```
import { getManyDocs } from "@junobuild/core";const docPair1 = {  collection: "my_collection",  key: "my_document_key_1"};const docPair2 = {  collection: "my_other_collection",  key: "my_document_key_2"};const docs = await getManyDocs({ docs: [docPair1, docPair2] });
```

---

## Update a document

To update a document, use the `setDoc` function with its current version to validate that the most recent entry is being updated:

```
import { setDoc } from "@junobuild/core";await setDoc({  collection: "my_collection_key",  doc: {    key: myId,    data: myExample,    version: 3n  }});
```

The `version` must match the current version of the last document within the satellite; otherwise, the call will fail. This prevents unexpected concurrent overwrites, which is useful, for example, if your users use your projects simultaneously on multiple devices.

**Tip:**

You can spread the document you have previously retrieved, for example with `getDoc`, to populate the `version` and `key` fields.

```
import { setDoc } from "@junobuild/core";await setDoc({  collection: "my_collection_key",  doc: {    ...myDoc, // includes 'key' and 'version'    data: myNewData  }});
```

---

## Set multiple documents

You might need to set multiple documents, whether within the same collection or across collections, all at once in an atomic manner. This ensures that if any of the creations or deletions fail, the entire batch will be automatically reverted.

You can achieve this using the `setManyDocs` function:

```
import { setManyDocs } from "@junobuild/core";const update1 = {  collection: "my_collection",  doc: {    key: "my_document_key_1",    data: {      hello: "world"    }  }};const update2 = {  collection: "my_other_collection",  doc: {    key: "my_document_key_2",    data: {      count: 123    }  }};const docs = await setManyDocs({ docs: [update1, update2] });
```

---

## List documents

The `listDocs` function is used to retrieve documents from a specified collection.

```
import { listDocs } from "@junobuild/core";const myList = await listDocs({  collection: "my_collection_key"});
```

### Parameters

The function requires a collection and accepts various optional parameters, including a matcher (a regex applied to the document keys and descriptions), pagination options, and sorting order.

1.  **`collection`** (required)
    
    *   **Description**: The key of the collection from which documents are to be listed.
    *   **Type**: `string`
2.  **`filter`** (optional)
    
    *   **Description**: An optional object that can be used to provide various parameters to filter documents.
    
    a. **`matcher`** (optional)
    
    *   **Description**: An object used to filter documents based on their keys or descriptions using regular expressions.
        
    *   **Type**: `ListMatcher`
        
        ```
        interface ListMatcher {  key?: string;  description?: string;  createdAt?: ListTimestampMatcher;  updatedAt?: ListTimestampMatcher;}
        ```
        
        *   **key**: A regex to match against document keys.
        *   **description**: A regex to match against document descriptions.
        *   **createdAt**: A `ListTimestampMatcher` to filter documents based on their creation timestamp.
        *   **updatedAt**: A `ListTimestampMatcher` to filter documents based on their last update timestamp.
    *   **Type**: `ListTimestampMatcher` can be used to specify criteria for timestamp matching.
        
        ```
        type ListTimestampMatcher =  | {      matcher: "equal";      timestamp: bigint;    }  | {      matcher: "greaterThan";      timestamp: bigint;    }  | {      matcher: "lessThan";      timestamp: bigint;    }  | {      matcher: "between";      timestamps: {        start: bigint;        end: bigint;      };    };
        ```
        
        *   **matcher**: Specifies the type of timestamp comparison. Can be one of the following:
            
            *   **equal**: Matches documents where the timestamp is exactly equal to the specified value.
            *   **greaterThan**: Matches documents where the timestamp is greater than the specified value.
            *   **lessThan**: Matches documents where the timestamp is less than the specified value.
            *   **between**: Matches documents where the timestamp falls within a specified range.
        *   **timestamp**: Used with `equal`, `greaterThan`, and `lessThan` matchers to specify the exact timestamp for comparison.
            
        *   **timestamps**: Used with the `between` matcher to specify a range of timestamps. The range is inclusive of both the start and end values.
            
    
    b. **`paginate`** (optional)
    
    *   **Description**: An object to control pagination of the results
        
    *   **Type**: `ListPaginate`
        
        ```
        interface ListPaginate {  startAfter?: string;  limit?: number;}
        ```
        
        *   **startAfter**: A string key to start listing documents after this key.
        *   **limit**: The maximum number of documents to return.
    
    c. **`order`** (optional)
    
    *   **Description**: Control the sorting order of the results.
        
    *   **Type**: `ListOrder`
        
        ```
        interface ListOrder {  desc: boolean;  field: ListOrderField;}type ListOrderField = "keys" | "updated_at" | "created_at";
        ```
        
    
    d. **`owner`** (optional)
    
    *   **Description**: The owner of the documents.
        
    *   **Type**: `ListOwner`
        
        ```
        type ListOwner = string | Principal;
        ```
        

**Example:**

Usage of the parameters:

```
import { listDocs } from "@junobuild/core";const myList = await listDocs({  collection: "my_collection_key",  filter: {    matcher: {      key: "^doc_",      description: "example",      createdAt: {        matcher: "greaterThan",        timestamp: 1627776000n      },      updatedAt: {        matcher: "between",        timestamps: {          start: 1627770000n,          end: 1627900000n        }      }    },    paginate: {      startAfter: "doc_10",      limit: 5    },    order: {      desc: true,      field: "updated_at"    },    owner: "some_owner_id_or_principal"  }});
```

The function returns the documents and various information, in the form of an object whose interface is given below.

```
{  items: []; // The data - array of documents  items_length: bigint; // The number of documents - basically items.length  items_page?: bigint; // If the query is paginated, at what page (starting from 0) do the items find the place  matches_length: bigint; // The total number of matching results  matches_pages?: bigint; // If the query is paginated, the total number (starting from 0) of pages}
```

---

## Count documents

The `countDocs` function is used to count the number of documents in a specified collection without retrieving the actual documents.

```
import { countDocs } from "@junobuild/core";const count = await countDocs({  collection: "my_collection_key"});
```

### Usage

This function accepts similar parameters as the `listDocs` function, including `collection`, `matcher`, and `owner`, and returns the count of matching documents.

For detailed information on how to use these parameters, refer to the ([List documents](#list-documents)) section.

The return value is the same as the `items_length` property from the `listDocs` function, providing the count of documents that match the criteria.

---

## Delete

There are multiple ways to delete documents from your Datastore.

### Delete a document

To delete a document, use the `deleteDoc` function, which performs version validation to ensure that the most recent document is being deleted:

```
import { deleteDoc } from "@junobuild/core";await deleteDoc({  collection: "my_collection_key",  doc: myDoc});
```

The document must include the current `version` from the latest entry within the satellite; otherwise, the call will fail. This prevents unexpected concurrent overwrites, which is particularly useful if your users access your projects simultaneously on multiple devices.

### Delete multiple documents

To delete multiple documents in an atomic manner, you can use the function `deleteManyDocs`:

```
import { deleteManyDocs } from "@junobuild/core";await deleteManyDocs({ docs: [myDoc1, myDo2, myDoc3] });
```

### Delete filtered documents

The `deleteFilteredDocs` function allows you to delete multiple documents from a collection based on specific filter criteria. This function simplifies bulk deletions by leveraging the same parameters as the ([listDocs](#list-documents)) function for filtering.

```
import { deleteFilteredDocs } from "@junobuild/core";await deleteFilteredDocs({  collection: "my_collection_key",  filter: {    // Same options as filter of listDocs  }});
```

---

## Options

This section covers additional options that can be used with most of the functions listed above.

### Certified Reads

All read functions support a `certified` option that can be enabled to guarantee cryptographic verification of the returned data.

By default, uncertified reads are used for better performance and UX. Those are faster but do not provide cryptographic guarantees.

When `options.certified` is enabled, the function performs an update call under the hood. This ensures the response is verified by the Internet Computer but may increase latency.

#### When to Use Certified Reads

Certified reads matter when trust in displayed information is more important than speed, or when your app exposes publicly verifiable data â€” such as user balances, or voting results.

For those use cases, a common pattern is deduplicating the call: making an uncertified call for UX purposes â€” fetching and displaying data quickly â€” and an update call in parallel, which might take longer but ensures verification. If the latter fails, revert the information and warn users about the issue.

#### Example

```
import { listDocs } from "@junobuild/core";await listDocs({  collection: "my_collection_key",  options: { certified: true }});
```

### Node.js Usage

In Node.js or outside the browser, you must explicitly pass a `satellite` parameter specifying the satellite configuration, so the function knows which satellite to target and how to connect to it.

This is required because `initSatellite()` is only available in browser environments.

**Important:**

You never need to set this parameter in a browser context.

#### Example

```
import { getDoc } from "@junobuild/core";await getDoc({  collection: "my_collection_key",  key: "my_document_key",  satellite: {    identity: myIdentity,    satelliteId: "aaaaa-bbbbb-ccccc-ddddd-cai",    container: true  }});
```

# Lifecycle

Understand the full journey of Serverless Functions in Juno, from setup and development to deployment and maintenance.

---

## Initial Setup

If you didnâ€™t use a template or skipped the language selection during setup, you can run `juno functions eject` at the root of your project. This command configures your project with the appropriate setup based on your language of choice. For Rust, it includes a `Cargo.toml` and a `lib.rs` file. For TypeScript, it sets up an `index.ts` file.

---

## Developing Functions

Once your project is scaffolded, you can start writing your functions. Use the CLI to build them with:

```
juno functions build
```

If you start the emulator (see chapter below) in watch mode, your functions will be rebuilt automatically on save, so you donâ€™t need to run this command manually.

---

## Local Development

For local development and testing, a sandbox environment is essential. You can establish this environment by running the CLI command `juno emulator start`.

**Info:**

Find more information about local development in the [documentation](/docs/guides/local-development.md).

The local sandbox environment supports hot reloading. This means that the container will automatically redeploy your local Satellite each time `juno functions build` is executed and a new version is produced.

If you start the emulator with the `--watch` flag, it will also rebuild your functions automatically when changes are detected.

---

## Deploying

Juno offers two main ways to deploy your serverless functions, depending on whether you're working locally or integrating with a CI pipeline like GitHub Actions.

---

### 1\. Direct Deploy

If you're developing locally or in another environment where the **access key has admin privileges**, you can deploy the latest build directly:

```
juno functions upgrade
```

*   âœ… Skips the CDN.
*   âœ… Immediate deployment.
*   ðŸ” Requires access key with upgrade permission.
*   ðŸ“¦ Uses the default path: `./target/deploy/satellite.wasm.gz`.

Optional:

```
juno functions upgrade --src ./path/to/custom-build.wasm.gz
```

---

### 2\. With CDN + Approval Workflow

If you're using CI (like GitHub Actions) or an environment where your **access key has write privileges**:

#### a) Publish to CDN

In your GitHub Action or script:

```
juno functions publish
```

With options:

```
juno functions publish --mode staging --src ./path/to/build.wasm.gz
```

*   ðŸ“¤ Uploads to the Satelliteâ€™s CDN release.
*   ðŸ” Requires access key with **editor** role.

#### b) Upgrade from CDN

From your local CLI or in the Console UI, you can then upgrade.

```
juno functions upgrade --cdn
```

*   ðŸ”Ž Interactively selects the WASM version from the published CDN.
*   ðŸ§¾ Only deploys with a key that has **upgrade** rights.
*   ðŸ•µï¸ If your key is **submit-only**, the change will wait for approval in the Console UI or CLI.

---

### 3\. Optional Approval Flow

If you're using CI (like GitHub Actions) or an environment where your **access key has submit privileges** â€” meaning it cannot directly modify or write data â€” you can follow a workflow that requires manual approval before deployment.

```
juno functions publish --no-apply
```

Then the published release:

*   Becomes a **pending change**.
*   Must be **reviewed and applied** manually.

Apply the change either in the Console UI or directly using the CLI.

#### ðŸ“œ List submitted changes

```
juno changes list
```

#### âœ… Apply a specific change

```
juno changes apply --id <change_id>
```

Once applied, the Satellite can then be upgraded in the CLI or respectively in the Console UI using:

```
juno functions upgrade --cdn-path <published_version_path>
```

---

## Summary

A quick reference for the most common CLI commands and deployment workflows when working with serverless functions in Juno.

### ðŸ› ï¸ Common CLI Commands

| Command(s) | Scenario |
| --- | --- |
| `juno functions eject` | Initializes your project for writing serverless functions. |
| `juno emulator start` | Starts the emulator. |
| `juno functions build` | Compiles your custom Satellite's code. Changes are automatically redeployed locally. |

### ðŸš€ Deployment Scenarios

| Command(s) | Scenario |
| --- | --- |
| `juno functions upgrade` | Upgrades your serverless functions immediatly. |
| `juno functions upgrade --src ./path/to/custom-build.wasm.gz` | Use a custom WASM path to upgrade. |
| `juno functions publish` in CI â†’ `juno functions upgrade --cdn` in CLI or Console UI | CI/CD with write access. |
| `juno functions publish --no-apply` in CI â†’ `juno changes apply` â†’ `juno functions upgrade --cdn-path ...` | CI/CD with submit-only access. |
| `juno functions publish --mode staging` | CI/CD using staging environment. |

# Logs

Writing and viewing logs is a crucial tool for debugging and monitoring your code. Serverless Functions offer you the option to utilize loggers to report status effectively.

![A screenshot of the Juno&#39;s Console feature to browse logs](/assets/images/functions-754bffa459e2345077924846bf09ef3d.webp)

---

## Native Logging

The Internet Computer provides a native, simple logging system where logs are persisted within the state up to a maximum size of 4 KiB.

**Note:**

If new logs exceed the 4 KiB limit, the oldest entries will be removed. Logs persist across Satellite upgrades.

These logs are the preferred method for writing and viewing logs, as they are more efficient and cost-effective compared to the custom solution below. They also persist regardless of whether the update call succeeds or fails.

However, native logs do not yet support log levels, that's why all entries will appear as "Error" in the Juno Console.

Any printed or trapped messages using the `ic_cdk` crate are automatically collected as logs.

### Example Usage

```
fn log() {    ic_cdk::print("This is a log entry.");    ic_cdk::trap("There was an error.");}
```

---

## Custom Logging

Custom logging provides a flexible way to track and debug function executions within your Satellite if the native logging does not answer your needs.

### How does it work?

Logs are stored in stable memory, accommodating up to 100 entries. Once this limit is reached, the oldest entry is discarded. It's important to note that since logs are saved in memory, your hooks should return a successâ€”meaning they should not trapâ€”otherwise, the information cannot be preserved.

### Available loggers

| Logger | Level | Description |
| --- | --- | --- |
| `log` | Info | Logs a message. |
| `log_with_data` | Info | Logs a message with additional serialized data. |
| `info` | Info | Logs an informational message. |
| `info_with_data` | Info | Logs an informational message with additional serialized data. |
| `debug` | Debug | Logs an debug-level message. |
| `debug_with_data` | Debug | Logs a debug-level message with additional serialized data. |
| `warn` | Warning | Logs a warning message. |
| `warn_with_data` | Warning | Logs a warning message with additional serialized data. |
| `error` | Error | Logs an error message. |
| `error_with_data` | Error | Logs an error message with additional serialized data. |

# Rust

This page covers advanced options for writing serverless functions in Rust.

---

## Including the Satellite

After defining your Functions, at the very end of your `lib.rs` module, include the Satellite to ensure that your custom logic and the default features or Juno are properly registered and executable within the Juno ecosystem.

**Important:**

This is crucial for compatibility with the Juno Console and CLI, as it expects the Satellite to expose the necessary functionality for monitoring, deployment, and interaction. Without this macro, certain features in the Console may not function correctly.

```
include_satellite!();
```

---

## Feature Selection

When you run `juno functions eject`, all the available hooks and assertions are scaffolded in your `lib.rs` module. However, if you donâ€™t have to implement all of them for example to improve readability or reduce unnecessary logic, you can selectively enable only the features you need.

To do this, disable the default features in your `Cargo.toml` and explicitly specify only the ones you want to use.

For example, if you only need `on_set_doc` and `assert_set_doc`, configure your `Cargo.toml` like this:

```
[dependencies]junobuild-satellite = { version = "0.0.21", default-features = false, features = ["on_set_doc", "assert_set_doc"] }
```

With this setup, only `on_set_doc` and `assert_set_doc` must be implemented with custom logic, while other hooks and assertions will not be included in your Satellite.

---

## Maintenance

After deployment, keeping your Satellite functional and optimized requires ongoing monitoring and updates. Staying up to date is also a key factor, as we may introduce new features that need to be integrated into your Satellite to ensure full functionality within the Juno Console.

Since your project includes all Satellite features using `include_satellite!();`, it's essential to stay in sync with Junoâ€™s updates to maintain compatibility.

**Caution:**

Always upgrade iteratively and avoid skipping version numbers. While we strive to minimize breaking changes, it's crucial to upgrade through each released version sequentially.

For example, if you're on **v0.0.23** and the latest release is **v0.0.26**, first upgrade to **v0.0.24**, then **v0.0.25**, and finally **v0.0.26**. Skipping versions could lead to unexpected issues.

### Updating Your Satellite

To upgrade your Satellite, bump the dependencies in your `Cargo.toml` file located in `/src/satellite/`. The key dependencies to check and update are:

*   `junobuild-satellite`
*   `junobuild-storage`
*   `junobuild-macros`
*   `ic_cdk`
*   `candid`

If other crates in your project depend on these, they should also be upgraded accordingly.

The recommended versions for each release can be found in the [changelog](/changelog) or [release notes on GitHub](https://github.com/junobuild/juno/releases).

If you need assistance, feel free to reach out through the available support channels.

---

## Versioning

Every Satellite that runs your serverless functions includes a version number, defined in the `Cargo.toml` file of your project:

```
[package]name = "satellite"version = "0.1.0"
```

This version is embedded into the compiled Wasm binary and displayed in the Juno Console. It helps you:

*   Track which version of your serverless logic is currently deployed.
*   Debug more effectively by matching behavior in the Console with specific code versions.
*   Move independently of Juno updates â€” you're in full control of your own function versioning.

You can use any versioning scheme that suits your development workflow (e.g. `0.1.0`, `1.0.0-beta`, `2025.04.18`...).

---

## Additional Notes

WebAssembly (Wasm) binaries serve as the compilation target for the Satellites. While Juno's CLI automatically specifies this target for you, manual execution of certain `cargo` commands necessitates explicitly providing this target.

For instance:

```
cargo clippy --target=wasm32-unknown-unknown
```

# TypeScript

This page covers advanced options for writing serverless functions in TypeScript.

---

## Maintenance

Since your project includes all Satellite features, it's essential to stay in sync with Junoâ€™s updates to maintain compatibility.

Always check the [releases](https://github.com/junobuild/juno/releases) page for the latest changes, and update your local container image (source [repo](https://github.com/junobuild/juno-docker)) accordingly to ensure you're running the latest runtime and features.

**Caution:**

Always upgrade iteratively and avoid skipping version numbers. While we strive to minimize breaking changes, it's crucial to upgrade through each released version sequentially.

For example, if you're on **v0.0.23** and the latest release is **v0.0.26**, first upgrade to **v0.0.24**, then **v0.0.25**, and finally **v0.0.26**. Skipping versions could lead to unexpected issues.

---

## Versioning

When writing serverless functions in TypeScript, Juno uses the version defined in your projectâ€™s `package.json`. This version is embedded into the compiled Wasm module and shown in the Juno Console, making it easier to keep track of deployments.

By default, the version is inherited from the root-level `version` field:

```
{  "name": "demo",  "version": "0.0.10"}
```

However, if you want to version your functions independently from your app or workspace, you can define a custom version field specifically for Juno Functions:

```
{  "name": "demo",  "version": "0.0.10",  "juno": {    "functions": {      "version": "0.0.4"    }  }}
```

This version is embedded into the compiled Wasm binary and displayed in the Juno Console. It helps you:

*   Track which version of your serverless logic is currently deployed.
*   Debug more effectively by matching behavior in the Console with specific code versions.
*   Move independently of Juno updates â€” you're in full control of your own function versioning.

You can use any versioning scheme that suits your development workflow (e.g. `0.1.0`, `1.0.0-beta`, `2025.04.18`...).

# Configuration

You can customize your hosting environment to fit your needs, including:

*   Specify which `source` files in your local project directory you want to deploy? ([Learn how.](#source))
*   Ignore some files during deployment. ([Learn how.](#ignore-files))
*   Configure HTTP `headers` to pass along additional information about a request or a response. ([Learn how.](#http-headers))
*   Serve a customized 404 page. ([Learn how.](#customize-a-404not-found-page))
*   Set up `redirects` for pages that you've moved or deleted. ([Learn how.](#redirects))
*   Set up `rewrites`. ([Learn how.](#rewrites))
*   Customize file `compression` for optimal performance. ([Learn how.](#precompress))
*   Customize the `encoding` behavior of your files. ([Learn how.](#encoding-types))
*   Allow your project to be embedded as an `iframe`. ([Learn how.](#iframe))
*   Customize `assertions` to modify the default verification behavior of the CLI. ([Learn how.](#assertions))

---

## Where do you define your Hosting configuration?

Your hosting configuration is defined in the Juno [configuration](/docs/reference/configuration.md) file, which is automatically created when you run [juno config init](/docs/reference/cli.md#init) or [juno hosting deploy](/docs/reference/cli.md#deploy) for the first time.

---

## How do you apply your changes?

To apply any changes, execute the [juno config apply](/docs/reference/cli.md#apply) command with the CLI.

---

## Options

The list below outlines the available hosting options you can configure to tailor your hosting.

### Source

The `source` field specifies the directory that contains the built assets for your satellite. This is typically the output directory generated by your build process after running a command like `npm run build`.

Commonly, or if you are using the templates, these are the folders that can be set as the `source` field:

| Framework | Source |
| --- | --- |
| Next.js | `out` |
| React, Astro, or Vue | `dist` |
| SvelteKit | `build` |
| Angular | `dist/<your-project-name>/browser` |

Juno uses this directory to locate the files that will be deployed as part of your satellite. Ensure that this directory includes all the necessary assets, such as HTML, JavaScript, CSS, and any other static or dynamic resources your application requires.

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist"  }});
```

### Ignore files

The `ignore` attribute allows you to exclude certain files from being deployed to your satellite.

This attribute works similarly to Git's `.gitignore`, and you can specify which files to ignore using globs.

Here is an example of how the ignore attribute can be utilized:

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    ignore: ["**/*.txt", ".tmp/"]  }});
```

### HTTP Headers

Headers allow the client and the satellite to pass additional information along with a request or a response. Some sets of headers can affect how the browser handles the page and its content.

For instance, you may want to set a specific `Cache-Control` for performance reasons.

Here's an example of the `headers` object:

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    storage: {      headers: [        {          source: "/",          headers: [["Cache-Control", "public,max-age=0,must-revalidate"]]        },        {          source: "assets/fonts/*",          headers: [["Cache-Control", "max-age=31536000"]]        },        {          source: "**/*.jpg",          headers: [            ["Cache-Control", "max-age=31536000"],            ["Access-Control-Allow-Origin", "*"]          ]        }      ]    }  }});
```

This `source` attribute works similarly to Git's `.gitignore`, and you can specify which files match the headers using globs.

The `headers` is an array of objects, each containing `key` and `value`, and these apply to the matching paths.

**Note:**

*   The `Content-Type` header is calculated automatically and cannot be altered.
*   No validation or check for uniqueness is performed. For example, if a header matches a file based on multiple rules, multiple headers will be set.
*   Likewise, if you provide the same header when you [upload](https://juno.build/docs/build/storage#upload-file) file to your "Storage" and within the configuration, both headers will be set in the response.

### Customize a 404/Not Found page

By default, all unknown paths are automatically rewritten to `/index.html`. However, if you wish to serve a custom `404 Not Found` error when a user attempts to access a non-existent page, you can do so without requiring additional configuration.

Simply upload a custom `404.html` file to your satellite that should be served from the root path of your site.

### Redirects

Use a URL redirect to prevent broken links if you've moved a page or to shorten URLs. For example, you could redirect a browser from `juno.build/start-building` to `juno.build/get-started.html`.

Here's the basic structure for a `redirects` attribute.

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    storage: {      redirects: [        {          source: "/hello",          location: "/world/index.html",          code: 301        }      ]    }  }});
```

The `redirects` attribute contains an array of redirect rules:

| Field | Description |
| --- | --- |
| **source** | This `source` attribute works similarly to Git's `.gitignore`, and you can specify which files match the redirects using globs. |
| **location** | A relative path to where the browser should make a new request. |
| **code** | The HTTPS response code. Use a type of `301` for 'Moved Permanently' or `302` for 'Found' (Temporary Redirect). |

### Rewrites

You can utilize optional rewrites to display the same content for multiple URLs. Rewrites are especially useful when combined with pattern matching, allowing acceptance of any URL that matches the pattern.

Here's the basic structure for a `rewrites` attribute.

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    storage: {      rewrites: [        {          source: "/hello/**",          destination: "/hello/world.html"        }      ]    }  }});
```

This `source` attribute works similarly to Git's `.gitignore`, and you can specify which files match the rewrites using globs.

**Note:**

*   Rewrites are only applied to requests that do not match any existing resources.
*   By default, all unknown paths are automatically rewritten to `/index.html` (or `/404.html` if you provide such a page). You cannot disable this default behavior.

### GZIP

When deploying your application, the CLI automatically searches for files matching the pattern `**/*.+(css|js|mjs|html)` in the `source` folder to optimize them using Gzip compression. This improves the performance of your app when it is served on the web.

By default, precompression stores **both** the original and compressed versions in Storage.

You can disable it entirely or customize which files are precompressed, whether to keep originals, and which compression algorithm to use.

**Note:**

If you change the precompress configuration and your project has already been deployed, run `juno hosting clear` before redeploying to ensure you change is applied.

#### Disable precompression

Set the `precompress` option to `false` in your configuration:

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    precompress: false  }});
```

#### Customize the file matching pattern

If you want to customize the default pattern `**/*.+(css|js|mjs|html)` to better suit your needs, you can specify your own pattern. For example:

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    precompress: {      pattern: "**/*.jpg" // precompress JPEG files only    }  }});
```

#### Decide what happens to original files

The `mode` option controls what happens to the original files after compression:

*   `"both"` â€” upload both the original and the compressed version. _(default)_
*   `"replace"` â€” upload only the compressed version and serve it with the appropriate `Content-Encoding` header.

**Warning:**

If you use `replace` for HTML, some social media crawlers (e.g. Twitter, LinkedIn) may not be able to fetch your pages correctly, resulting in missing or broken social previews.

To avoid this, instead of providing a single precompression rule, it's recommended to fine-tune the behavior using an **array of rules** (([see below](#use-multiple-rules))).

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    precompress: {      mode: "replace"    }  }});
```

#### Choose the compression algorithm

By default, precompression uses **Gzip** (`algorithm: "gzip"`) because it offers a good balance between compression speed, compatibility, and size.

You can switch to **Brotli** (`algorithm: "brotli"`) for potentially smaller files, especially for text-based assets such as those compressed by default like HTML, CSS, and JavaScript.

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    precompress: {      algorithm: "brotli"    }  }});
```

#### Use multiple rules

**Tip:**

This strategy works great for modern static sites.

In some cases, particularly when using `mode: replace`, you may want to apply different precompression strategies depending on the file type. For example, using replace for JavaScript and CSS files, but doing so for HTML can break social media previews.

To handle this, the precompress option also accepts an array of rules:

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    precompress: [      {        pattern: "**/*.+(js|mjs|css)",        algorithm: "brotli",        mode: "replace"      },      {        pattern: "**/*.html",        algorithm: "brotli",        mode: "both"      }    ]  }});
```

### Encoding types

When deploying, the CLI automatically maps the encoding type based on the file extension. The encoding information is then used in the satellite to provide the appropriate HTTP response header `Content-Encoding`.

The default mappings are as follows:

*   `.Z` = `compress`
*   `.gz` = `gzip`
*   `.br` = `br`
*   `.zlib` = `deflate`
*   rest = `identity` (no compression)

You can also customize the encoding behavior by using the "encoding" attribute in the configuration file.

This attribute works similarly to Git's `.gitignore`, and you can specify which files to ignore using globs.

Here is an example of how the "encoding" attribute can be utilized:

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    encoding: [["**/releases/*.gz", "identity"]]  }});
```

### iframe

For security reasons and to prevent click-jacking attacks, dapps deployed with Juno are, by default, set to deny embedding in other sites.

You can customize this behavior by setting the `iframe` option to either `same-origin`, which restricts your pages to be displayed only if all ancestor frames have the same origin as the page itself, or `allow-any`, which allows your project to be embeddable by any site.

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    storage: {      iframe: "same-origin"    }  }});
```

### Assertions

The CLI conducts several assertions when interacting with your Satellite, one of which involves monitoring the heap memory size. Typically, the CLI checks to ensure that the heap memory does not exceed the 1 GB limit before deployment. For instance, if your heap memory usage is close to 900 MB, the CLI will prompt you to confirm the deployment.

You can customize this behavior by adjusting the heap memory limit in bytes. For example, to set a new limit of 678 MB, update your configuration as follows:

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    assertions: {      heapMemory: 678000000    }  }});
```

Alternatively, these checks can be completely disabled. To do so, set the `heapMemory` assertion to `false`:

juno.config.js

```
import { defineConfig } from "@junobuild/config";export default defineConfig({  satellite: {    ids: {      production: "qsgjb-riaaa-aaaaa-aaaga-cai"    },    source: "dist",    assertions: {      heapMemory: false    }  }});
```

# Development

This section covers how to configure and manage your custom domain in Juno, including setting up DNS records, troubleshooting common issues, and ensuring compatibility with various domain providers.

---

## Connecting Your Domain

To connect your custom domain, follow these steps:

1.  Start the custom domain wizard from the Juno console [hosting](https://console.juno.build/hosting) page
2.  Enter the desired domain name for your satellite
3.  Log into your domain provider's site and configure the DNS records as indicated by Juno
4.  Continue the process in Juno

Please note that it may take several minutes to set up your custom domain after the wizard is completed and up to 24 hours for your domain provider to reflect the changes.

---

## DNS records

To configure DNS records, you will be requested to use `CNAME` records. Some domain providers do not provide such types. Instead, DNS providers often support so-called `CNAME` flattening. To this end, these DNS providers offer flattened record types, such as `ANAME` or `ALIAS` records, which can be used instead of the `CNAME` to `icp1.io`.

Some DNS providers require you to specify the main domain. For example, you might have to specify your full domain `foo.bar.com` for the `CNAME` entry related to `icp1.io` instead of only `foo` as displayed by our [console](/docs/terminology.md#console).

If you ever encounter issues configuring your DNS, you can also refer to the [Troubleshooting](https://internetcomputer.org/docs/current/developer-docs/production/custom-domain/#troubleshooting) section for further assistance.

### Cloudflare

The DNS entries presented in the console are exactly the ones that should be configured in Cloudflare.

However, based on our experience, to enable the custom domain properly, the following settings in Cloudflare should be disabled:

*   DNS > Settings > Disable DNSSEC
*   SSL/TLS > Overview > Set "Your SSL/TLS encryption mode" to "Off (not secure)". A SSL certificate will be automatically ordered by configuring the custom domain.
*   SSL/TLS > Edge Certificates > Disable Universal SSL

Additionally, we recommend not proxying the DNS entries ("DNS only").

### Namecheap

This external guide provides instructions on how to configure the DNS records for [Namecheap](https://internetcomputer.org/docs/current/developer-docs/production/custom-domain/dns-setup#namecheap).

### GoDaddy

This external guide provides instructions on how to configure the DNS records for [GoDaddy](https://internetcomputer.org/docs/current/developer-docs/production/custom-domain/dns-setup#godaddy).

### Google Domains

Google Domains does not support `CNAME` records for the apex domain. For this reason, we suggest transferring the domain to ([Cloudflare](#cloudflare)).

### Other Limited Providers

We are aware of a few other providers that also do not support `CNAME` records for the apex domain. Similar to Google Domains, we advise transferring the domain to ([Cloudflare](#cloudflare)) in order to overcome this limitation.

*   HostGator
*   Infomaniak

---

## Status

The status of the configuration of your custom domain can be one of the following:

**Tip:**

â³ DNS propagation can take time! It may take several minutes to hours for changes to fully take effect. If your domain is not working as expected, avoid making multiple changes, as this can cause further delays.

If you're having trouble, feel free to reach out for assistanceâ€”weâ€™re happy to help!

*   `PendingOrder`: The registration request has been submitted and is waiting to be picked up.
*   `PendingChallengeResponse`: The certificate has been ordered.
*   `PendingAcmeApproval`: The challenge has been completed.
*   `Available`: The registration request has been successfully processed. Your custom domain is ready.
*   `Failed`: The registration request failed.

If one of the status `Pending...` is reached, the console will automatically refresh the status every few seconds until your domain is available.

# Collections

You can create or update a collection in the "Collections" tab in Juno's console under the [storage](https://console.juno.build/storage) view.

---

## Configuration

Each collection has a set of configurable options that define its behavior and limitations:

| Option | Mandatory | Description |
| --- | --- | --- |
| Key | Yes | A unique identifier for the collection. The key that you will use in your code to interact with a particular collection. |
| Read permission | Yes | Defines who can read documents in the collection. See ([Permissions](#permissions)) below. |
| Write permission | Yes | Defines who can create, update, or delete documents. See ([Permissions](#permissions)) below. |
| Memory | Yes | Specifies whether the collection uses `heap` or `stable` memory. This setting is permanent and cannot be changed after creation. The default is `stable` memory. For more information, see the related [documentation](/docs/miscellaneous/memory.md). |
| Max changes per user | No  | Limits the number of documents a single user can create, update, or delete in the collection. This helps maintain fair resource distribution across users. |
| Max size | No  | Sets an optional limit (in bytes) on the maximum size of individual assets that can be uploaded to a collection. |
| Max updates per minute | No  | Limits the number of creation, update and delete operations per minute to prevent excessive updates. |
| Immutable permissions | No  | If enabled, read and write permissions cannot be modified after creation. |

---

## Permissions

Permissions define who can read and write assets in a collection. Writing includes creating (uploading), updating, and deleting assets.

**Caution:**

Assets are publicly accessible on the Internet regardless of the permission schema. The rules are only applied when reading or writing the data through the library.

| Permission | Description |
| --- | --- |
| **Public** | Anyone can read or write assets in the collection. |
| **Private** | Only the creator (owner) of the asset can read or write to it. However, note that since satellite administrators manage the underlying infrastructure, they have the technical ability to modify access rules by changing its source code. |
| **Managed** | The owner of an asset, the administrator and editor of the satellite can read or write to it in the collection. |
| **Restricted** | Only satellite administrator and editor can read or write any asset in the collection. |

If not set to immutable, you can modify the permissions at any time, and the changes will take effect immediately.

**Tip:**

Any collection with read permissions set to `public`, `managed` or `restricted` will allow the developer to view its content in the console under the [storage](https://console.juno.build/storage) view.

# Development

This page explains how to manage assets using the Juno SDK, including uploading, listing, counting, and deleting files within your application. It also covers configuration options for optimizing storage and access control.

**Important:**

The functions described on this page are intended for use in the **client-side** of your app.

If you're looking to extend backend capabilities using serverless logic, refer to the [Functions documentation](/docs/build/functions.md).

---

## Concepts

Before working with the Storage API, it's helpful to understand two key concepts: assets and `fullPath`.

### Assets

Uploaded files become **assets** stored in your Satellite's Storage. These assets are web-accessible and can be managed with permissions, access tokens, and custom paths.

### fullPath

A `fullPath` is the **unique path** of an asset within your Satellite's storage. It determines the assetâ€™s public-facing URL and is used throughout the SDK to identify, retrieve, list, or delete the asset.

It always starts with a **slash**, and follows the structure:

```
/collection/filename
```

For example, uploading a file to the `"images"` collection with the filename `"logo.png"` results in:

```
/images/logo.png
```

#### Key points

*   If the asset is **not part of the frontend**, the `fullPath` always includes the **collection** name.
*   By default, the `fullPath` is automatically derived from the uploaded file's name (e.g. `/images/photo.jpg`).
*   You can override the path using a custom filename. These are e.g. both valid:
*   `/collection/hello.jpg`
*   `/collection/my/sub/path/hello.jpg`
*   The `fullPath` is effectively the **asset key** used in Juno Storage.
*   âš ï¸ Uploading a file to an existing `fullPath` will **overwrite** the existing file.

---

## Upload

The SDK provides multiple functions to upload files to your Satellite's Storage, each suited for different use cases.

---

### Upload file

To upload a file, use the following code:

```
import { uploadFile } from "@junobuild/core";const result = await uploadFile({  data,  collection: "images"});
```

#### Parameters

The `data` parameter is the file you want to upload. This is a `Blob`, typically selected using an HTML `<input type="file" />` element.

The `uploadFile` function provides various options, including:

*   `filename`: By default, Juno uses the file's filename. You can overwrite this and provide a custom filename. Example: `myimage.jpg`.
*   `fullPath`: The unique path where the asset will be stored and accessed.
*   `headers`: The headers can affect how the browser handles the asset. If no headers are provided Juno will infer the `Content-Type` from the file type.
*   `encoding`: The type of encoding for the file. For example, `identity` (raw) or `gzip`.

**Note:**

*   URL encoding is currently not supported on the Internet Computer. Therefore, it's important to keep in mind that your `filename` should not be encoded. That is why the library decodes the `filename` automatically.

#### Returns

The function returns the uploaded asset key as an object with the following fields:

*   `fullPath`: The unique path to the asset. Example: `/images/myimage.jpg`.
*   `name`: The name of the asset (typically the filename). Example: `myimage.jpg`.
*   `downloadUrl`: The URL to access the asset on the web or to download it. This URL can be used in a browser or embedded directly in HTML elements like `<img>` or `<a>`.

---

### Upload blob

The `uploadBlob` function works like ([`uploadFile`](#upload-file)) but does **not** infer the filename from the data. You must explicitly provide the `filename`.

```
import { uploadBlob } from "@junobuild/core";const result = await uploadBlob({  data: new Blob([myBuffer]),  filename: "generated.jpg",  collection: "images"});
```

This is useful when uploading raw binary data that wasn't selected via a file input.

---

### Protected asset

While all assets can be found on the internet, it is possible to make their URL difficult to guess so that they remain undiscoverable (**as long as they are not shared**) and considered "private".

Juno achieves this by using an optional access `token` query parameter.

```
import { uploadFile } from "@junobuild/core";import { nanoid } from "nanoid";const result = await uploadFile({  data,  collection: "images",  token: nanoid()});
```

Imagine a file "mydata.jpg" uploaded with an access token. Attempting to access it through the URL "[https://yoursatellite/mydata.jpg](https://yoursatellite/mydata.jpg)" will not work. The asset can only be retrieved if a `token` parameter is provided: "[https://yoursatellite/mydata.jpg?token=a-super-long-secret-id](https://yoursatellite/mydata.jpg?token=a-super-long-secret-id)".

---

## List assets

The `listAssets` function is used to retrieve assets from a specified collection.

```
import { listAssets } from "@junobuild/core";const myList = await listAssets({  collection: "my_collection_key"});
```

#### Parameters

The function requires a collection and accepts various optional parameters, including a matcher (a regex applied to the assets fullPaths and descriptions), pagination options, and sorting order.

**Note:**

`listAssets` uses the same interface as `listDocs`. That is why the parameter `matcher` expect a value `key` to filter the assets according their `fullPath`.

1.  **`collection`** (required)
    
    *   **Description**: The key of the collection from which assets are to be listed.
    *   **Type**: `string`
2.  **`filter`** (optional)
    
    *   **Description**: An optional object that can be used to provide various parameters to filter assets.
    
    a. **`matcher`** (optional)
    
    *   **Description**: An object used to filter assets based on their keys (fullPaths) or descriptions using regular expressions.
        
    *   **Type**: `ListMatcher`
        
        ```
        interface ListMatcher {  key?: string;  description?: string;  createdAt?: ListTimestampMatcher;  updatedAt?: ListTimestampMatcher;}
        ```
        
        *   **key**: A regex to match against asset keys.
        *   **description**: A regex to match against asset descriptions.
        *   **createdAt**: A `ListTimestampMatcher` to filter assets based on their creation timestamp.
        *   **updatedAt**: A `ListTimestampMatcher` to filter assets based on their last update timestamp.
    *   **Type**: `ListTimestampMatcher` can be used to specify criteria for timestamp matching.
        
        ```
        type ListTimestampMatcher =  | {      matcher: "equal";      timestamp: bigint;    }  | {      matcher: "greaterThan";      timestamp: bigint;    }  | {      matcher: "lessThan";      timestamp: bigint;    }  | {      matcher: "between";      timestamps: {        start: bigint;        end: bigint;      };    };
        ```
        
        *   **matcher**: Specifies the type of timestamp comparison. Can be one of the following:
            
            *   **equal**: Matches assets where the timestamp is exactly equal to the specified value.
            *   **greaterThan**: Matches assets where the timestamp is greater than the specified value.
            *   **lessThan**: Matches assets where the timestamp is less than the specified value.
            *   **between**: Matches assets where the timestamp falls within a specified range.
        *   **timestamp**: Used with `equal`, `greaterThan`, and `lessThan` matchers to specify the exact timestamp for comparison.
            
        *   **timestamps**: Used with the `between` matcher to specify a range of timestamps. The range is inclusive of both the start and end values.
            
    
    b. **`paginate`** (optional)
    
    *   **Description**: An object to control pagination of the results
        
    *   **Type**: `ListPaginate`
        
        ```
        interface ListPaginate {  startAfter?: string;  limit?: number;}
        ```
        
        *   **startAfter**: A string key to start listing assets after this key.
        *   **limit**: The maximum number of assets to return.
    
    c. **`order`** (optional)
    
    *   **Description**: Control the sorting order of the results.
        
    *   **Type**: `ListOrder`
        
        ```
        interface ListOrder {  desc: boolean;  field: ListOrderField;}type ListOrderField = "keys" | "updated_at" | "created_at";
        ```
        
    
    d. **`owner`** (optional)
    
    *   **Description**: The owner of the assets.
        
    *   **Type**: `ListOwner`
        
        ```
        type ListOwner = string | Principal;
        ```
        

**Example:**

Usage of the parameters:

```
import { listDocs } from "@junobuild/core";const myList = await listDocs({  collection: "my_collection_key",  filter: {    matcher: {      key: ".*.png$", // match assets with .png extension      description: "holiday", // match description containing 'holiday'      createdAt: {        matcher: "greaterThan",        timestamp: 1627776000n      },      updatedAt: {        matcher: "between",        timestamps: {          start: 1627770000n,          end: 1627900000n        }      }    },    paginate: {      startAfter: "doc_10",      limit: 5    },    order: {      desc: true,      field: "updated_at"    },    owner: "some_owner_id_or_principal"  }});
```

The function returns the assets and various information, in the form of an object whose interface is given below.

```
{  items: []; // The data - array of assets without their content  items_length: bigint; // The number of assets - basically items.length  items_page?: bigint; // If the query is paginated, at what page (starting from 0) do the items find the place  matches_length: bigint; // The total number of matching results  matches_pages?: bigint; // If the query is paginated, the total number (starting from 0) of pages}
```

---

## Download URL

The `downloadUrl` function is used to generate a public URL for accessing a specific asset stored on a Satellite.

**Note:**

You get similar information directly from the result of an upload. This function can be used to generate the URL on the fly.

This URL can be used to:

*   Open the file directly in a browser
*   Embed the asset in HTML elements such as `<img src="...">` or `<a href="...">`
*   Trigger a download when used in an `<a href="..." download>` link

```
import { downloadUrl } from "@junobuild/core";const url = downloadUrl({  assetKey: {    fullPath: "/images/logo.png",    token: "a-secret-token" // optional  }});// Example usage<img src={url} alt="Logo" />
```

#### Parameters

*   **`assetKey`** (required)
    
*   **`fullPath`**: The full path to the asset (e.g., `/images/file.jpg`).
    
*   **`token`** (optional): A access token used to protect the asset.
    
*   **`satellite`** (optional) Required only in Node.js environments to specify which Satellite to use.
    

#### Returns

*   A `string` representing the full URL to access the asset.

**Note:**

If a `token` is provided when uploading the asset, it must also be included in the URL to access it. This makes the asset effectively private until shared with the token.

---

## Count assets

The `countAssets` function is used to count the number of assets in a specified collection without retrieving the actual assets.

```
import { countAssets } from "@junobuild/core";const assetCount = await countAssets({  collection: "my_collection_key"});
```

#### Usage

This function accepts similar parameters as the `listAssets` function, including `collection`, `matcher`, and `owner`, and returns the count of matching documents.

For detailed information on how to use these parameters, refer to the ([List assets](#list-assets)) section.

The return value is the same as the `items_length` property from the `listAssets` function, providing the count of assets that match the criteria.

---

## Delete

There are multiple ways to delete assets from your Storage.

### Delete asset

To delete an asset, you only need to provide its `fullPath`. Unlike the [datastore](/docs/build/datastore.md), there is no timestamp validation performed when deleting an asset.

```
import { deleteAsset } from "@junobuild/core";await deleteAsset({  collection: "images",  storageFile: myAsset});
```

### Delete multiple assets

To delete multiple assets in an atomic manner, you can use the function `deleteManyAssets`:

```
import { deleteManyAssets } from "@junobuild/core";const myAsset1 = {  collection: "hello",  fullPath: "/hello/world.jpg"};const myAsset2 = {  collection: "data",  fullPath: "/data/something.json"};await deleteManyAssets({ assets: [myAsset1, myAsset2] });
```

### Delete filtered assets

The `deleteFilteredAssets` function allows you to delete multiple assets from a collection based on specific filter criteria. This function simplifies bulk deletions by leveraging the same parameters as the ([listAssets](#list-assets)) function for filtering.

```
import { deleteFilteredAssets } from "@junobuild/core";await deleteFilteredAssets({  collection: "my_collection_key",  filter: {    // Uses the same filter options as listAssets  }});
```

---

## Options

This section covers additional options that can be used with most of the functions listed above.

### Certified Reads

All read functions support a `certified` option that can be enabled to guarantee cryptographic verification of the returned data.

By default, uncertified reads are used for better performance and UX. Those are faster but do not provide cryptographic guarantees.

When `options.certified` is enabled, the function performs an update call under the hood. This ensures the response is verified by the Internet Computer but may increase latency.

#### When to Use Certified Reads

Certified reads matter when trust in displayed information is more important than speed, or when your app exposes publicly verifiable data â€” such as user balances, or voting results.

For those use cases, a common pattern is deduplicating the call: making an uncertified call for UX purposes â€” fetching and displaying data quickly â€” and an update call in parallel, which might take longer but ensures verification. If the latter fails, revert the information and warn users about the issue.

#### Example

```
import { listAssets } from "@junobuild/core";await listAssets({  collection: "my_collection_key",  options: { certified: true }});
```

### Node.js Usage

In Node.js or outside the browser, you must explicitly pass a `satellite` parameter specifying the satellite configuration, so the function knows which satellite to target and how to connect to it.

This is required because `initSatellite()` is only available in browser environments.

**Important:**

You never need to set this parameter in a browser context.

#### Example

```
import { getAsset } from "@junobuild/core";await getAsset({  collection: "my_collection_key",  fullPath: "/images/logo.png",  satellite: {    identity: myIdentity,    satelliteId: "aaaaa-bbbbb-ccccc-ddddd-cai",    container: true  }});
```

# What makes Juno a great Heroku alternative

Heroku introduced a simple way to deploy apps â€” push code, and it ran in the cloud. It remains a solid choice for long-running, traditional web applications.

But today's stack is different. Modern apps favor lightweight deployments, usage-based execution, and infrastructure that doesn't require maintaining always-on containers.

Juno brings back Heroku-style simplicity for the modern era â€” giving you your own execution environment with no servers to manage and no platform control over your app.

---

## The Trade-Off: Always-On Containers vs Modern Execution

Heroku runs long-lived app containers. This works well for classic backend apps, but means:

*   You pay for uptime, even when idle
*   You manage long-running processes
*   Operational responsibility increases over time

With Juno, you still deploy your app â€” but it runs in a self-contained environment on demand, with no OS, runtime patching, or server process to maintain.

*   **You own the deployment**
*   **No server or container administration**
*   **No platform access to your code or data**

Same simplicity â€” modern execution.

---

## Feature Comparison

| Feature | Heroku (Traditional PaaS) | Juno (Modern Serverless) |
| --- | --- | --- |
| Architecture | Always-on containers (dynos) | Self-contained containers, executed on demand |
| Deployment | Git push | CLI or Git-based deploy |
| Maintenance | App + container upkeep | You deploy updates; no OS to maintain |
| Data / Storage | Add-ons | Built-in datastore & storage (optional) |
| Authentication | External add-ons | Built-in decentralized auth (optional) |
| Core Benefit | Classic simplicity | Ownership, modern workflow, no server overhead |

> **Note:** Juno isn't for persistent background workers or long-running processes. It's optimized for modern web apps.

---

## Cost Considerations

Heroku is easy to start with, but costs rise as your app grows â€” especially if it needs background processes, add-ons, or multiple environments.

Juno keeps things simple. You pay for your own isolated app environment and the resources it actually uses over time â€” no per-feature charges, no surprise jumps, no scaling tax.

This means:

*   Costs stay steady as your project evolves
*   No extra fees for enabling auth, data, or functions
*   You keep full control over how your app runs and spends

For long-term projects, Juno provides stability, ownership, and clarity â€” without managing servers and without unpredictable pricing.

---

## When Juno Makes the Most Sense

**Ideal for:**

*   Modern apps, dashboards, APIs, documentation sites
*   Teams who want Heroku-style simplicity without servers
*   Builders who value ownership and platform independence
*   Projects that don't require persistent processes

**Heroku still fits when:**

*   You need a long-running application server
*   You're operating a legacy stack
*   Your app has background jobs attached to the runtime

---

## The takeaway

Heroku pioneered simple cloud deployment.

Juno builds on that spirit â€” but for modern workloads and developers who want ownership, privacy, and a lightweight execution model without managing infrastructure.

If you love Heroku's simplicity but want a platform designed for the next decade, Juno is a natural evolution.

---

## Ready to try Juno?

Ready to explore Juno? [Start building](/docs/intro.md)

# What makes Juno a great Netlify alternative

Netlify has long been a go-to platform for frontend developers. It pioneered the Jamstack movement, offers smooth Git-based workflows, and makes shipping static sites fast and simple.

But as projects mature, needs evolve. Ownership starts to matter. Data and infrastructure control matter. Cost predictability matters. And having the freedom to run your application independently becomes increasingly important.

This is where Juno steps in. Juno provides the same simple deployment experience for static sites â€” but runs your project in a container you own, with full control over its execution. It's the convenience of managed infrastructure with the control of self-hosting.

---

## The Trade-Off: Convenience vs Control

Netlify's strength is its fully managed, centralized hosting. It handles everything, which is great â€” until you need:

*   Guarantees around application independence
*   Confidence your project can't be taken offline by a provider
*   Predictable long-term pricing
*   Ownership over your data and runtime

Juno flips the model. You get the same simple â€œgit push to deployâ€ flow, but you run your app in your own execution environment â€” without managing servers or ops.

*   **Your Own Hosting Container** â€” Your site runs in a container you own and control. No black-box environment.
*   **Unstoppable Delivery** â€” Hosted across independent nodes. No single provider can restrict or remove your project.

Same simplicity â€” more control.

---

## Feature Breakdown: Netlify's Jamstack vs Juno's Stack

| Feature | Netlify (Managed Jamstack) | Juno (Owned Execution) |
| --- | --- | --- |
| Deployment | Global CDN (Centralized) | Decentralized Containers (User-owned) |
| Static Hosting | Yes â€” fast and convenient | Yes â€” same simplicity, but with ownership |
| Functions | Lambda-based (Optional Add-on) | Rust/TypeScript Functions (Optional, Native) |
| Authentication | Netlify Identity (Add-on) | Built-in Privacy-First Auth (Optional) |
| Data / Storage | Add-ons (Forms, Large Media) | Built-in Datastore & Storage (Optional) |
| Core Benefit | Convenience & speed | Ownership, stability, independence |

> **Important:** This comparison focuses on static hosting. Juno also offers integrated backend services, but you can adopt them only if/when needed.

---

## Cost Advantage: Predictable & Transparent Pricing

Netlify's free tier is generous â€” but as traffic and features scale, costs can rise quickly due to:

*   Bandwidth overages
*   Build minutes
*   Paid add-ons (identity, serverless, large media)

Juno uses a simple usage-based model. You pay for compute and storage like a utility, without surprise bandwidth charges or per-feature pricing layers.

For long-running, growing projects, this creates financial predictability and independence.

---

## Simplicity First: Static Hosting Done Right

Both Netlify and Juno deliver a familiar, modern developer workflow:

*   Git-based deployments
*   Support for modern frameworks (Next.js static export, Astro, SvelteKit static, Vue, React, etc.)
*   CLI-first developer experience

The difference is that **Juno gives you ownership from day one**, with the option to add backend capabilities as your app grows â€” without switching platforms.

Start static. Scale when you're ready.

---

## Performance Considerations

Netlify's edge network is highly optimized and may have the slight edge for globally-distributed, ultra-low-latency workloads.

Juno delivers competitive static performance with the benefit of independence and data sovereignty.

For most sites â€” documentation, marketing, dashboards, landing pages â€” Juno provides excellent real-world performance with long-term control.

---

## When Juno Makes the Most Sense

**Best fit for:**

*   Static sites that may evolve into full apps later
*   Projects where data independence and platform neutrality matter
*   Teams planning long-term builds who want infrastructure control
*   Builders who want the ease of Netlify with a clear path to autonomy

**Trade-offs to consider:**

*   Smaller ecosystem vs Netlify's long-established plugins
*   SSR not supported â€” Juno is optimized for static + client-side apps

If you're deploying a quick hobby site and don't have long-term infrastructure needs, Netlify remains a great choice.

If you want the same ease â€” with ownership, clarity, and room to scale â€” Juno is a powerful Netlify alternative.

---

## Ready to try Juno?

Ready to explore Juno? [Start building](/docs/intro.md)

# What makes Juno a great Railway alternative

Railway has earned a strong reputation among developers by making deployment simple and removing infrastructure friction. It modernized the Heroku experience with a polished workflow and transparent usage-based pricing â€” great for teams who want to ship quickly without managing cloud resources.

But what if you want that same simplicity while keeping full control over how and where your application runs? What if you want to own your environment instead of depending on someone else's platform?

This is where Juno steps in â€” an open-source serverless platform that delivers a similar smooth development and deployment experience, but with true app ownership and privacy built in from day one.

---

## The Trade-Off: Managed Convenience vs. Ownership

Railway makes the cloud feel effortless â€” but your app ultimately runs inside someone else's system, governed by their operational rules and platform roadmap.

Juno flips that model. You get the same frictionless deployment and tooling, but your application lives in your own isolated execution environment.

That brings two major benefits:

*   **Your application, your environment** â€” Juno cannot access your code, data, or infrastructure.
*   **Resilient by design** â€” Your project runs in an independent execution layer, not tied to a single commercial provider.

You keep the convenience â€” without giving up control.

---

## Feature Breakdown: Railway's PaaS vs Juno's Owned Stack

| Feature | Railway (Managed Cloud) | Juno (Owned Environment) |
| --- | --- | --- |
| Deployment | Fully managed cloud | Self-contained environment you own |
| Backend services | External database & auth services | Built-in datastore, auth, and storage (optional) |
| Functions | Container-based execution | Rust/TS serverless functions |
| Data control | Platform-controlled environment | Full app and data ownership |
| Core benefit | Fast modern PaaS experience | Same simplicity with long-term control |

---

## Cost Advantage: Usage Simplicity vs. Predictable Ownership

Railway's metered pricing is clear and modern â€” you pay as your resources grow. But as your project succeeds, costs can rise and remain tied to a commercial cloud platform.

Juno offers consistent, usage-based pricing in an environment that's yours. You only pay for the resources your app consumes over time â€” no add-on fees, no tier upgrades, and no platform-driven pricing surprises.

For projects meant to run and evolve for years, this provides financial stability and confidence.

---

## Beyond Deployment: Your Full Stack, When You Need It

Railway shines for deploying apps quickly. For many setups, you still need to bring your own:

*   Authentication
*   Database
*   Object storage
*   Serverless compute
*   Access control logic

Juno includes those capabilities by default â€” and you can adopt them gradually. It's a full-stack environment that scales with your needs, without piecing together separate vendors or services.

---

## Performance Considerations

Railway leverages centralized cloud performance and may excel in certain latency-critical workloads.

Juno provides competitive real-world performance for the vast majority of modern web apps â€” with the added benefit of independence, stability, and private execution.

If your primary goal is ultra-optimized centralized edge workloads, Railway remains strong. If you value control and long-term resilience, Juno stands apart.

---

## What You Should Know

**Best fit for:**

*   Teams who want simplicity without platform dependence
*   Apps that may grow toward full-stack needs
*   Builders who want privacy and long-term ownership of their environment
*   Projects where stability and control matter more than managed cloud convenience

**Trade-offs to consider:**

*   Smaller ecosystem vs Railway's plugin ecosystem
*   No traditional SSR â€” Juno is built for static + client-side apps

---

## The Right Choice for Your Project

If you're deploying a traditional backend app and want instant PaaS convenience with managed infrastructure, Railway is a solid choice.

But if your application demands:

*   Your own execution environment
*   Integrated full-stack building blocks you control
*   Predictable, usage-based operating costs
*   An open platform that gives you independence

Then **Juno is a powerful Railway alternative** â€” all the developer convenience, without handing your app to someone else's platform.

---

## Ready to try Juno?

Ready to explore Juno? [Start building](/docs/intro.md)

# What makes Juno a great self-hosting alternative

For years, developers had two choices: host everything themselves, or rely on a managed platform.

Traditional self-hosting gives you full control â€” but also means managing servers, patching systems, setting up reverse proxies, configuring SSL, securing databases, watching logs, scaling when traffic hits, and fixing things at 2 AM.

Juno gives you the control and privacy of self-hosting, without the operational overhead. You get your own execution environment and data ownership â€” without maintaining machines, containers, or cloud networking.

---

## Control Without the Maintenance

Self-hosting means running and operating the entire stack:

*   Provisioning a VPS or bare metal server
*   OS updates and security patches
*   SSL and reverse proxy setup
*   Deployment pipelines and build tooling
*   Managing databases, backups, and certificates
*   Monitoring uptime and infrastructure health

With Juno, you still control your deployments â€” nothing runs or changes without your action â€” but you don't need to manage operating systems, server processes, firewall rules, or runtime security layers.

*   **You own the container and trigger upgrades**
*   **No OS maintenance or server configuration**
*   **Built-in environment hardening**
*   **Independent execution with no third-party access**

Same autonomy â€” dramatically less work.

---

## Feature Comparison

| Feature | Traditional Self-Hosting | Juno |
| --- | --- | --- |
| Infrastructure | VPS / bare metal | Self-contained container (no servers) |
| Setup | Manual | CLI + Git-based deployment |
| Maintenance | High (patches, security, upgrades) | None (platform handles it) |
| Core Services | Install & secure yourself | Built-in auth, datastore, storage |
| Availability | Single server unless custom setup | Replicated across independent nodes |
| Best For | Full-time operators / sysadmins | Developers who want control without ops |

---

## Cost Considerations

Self-hosting looks cheap on day one, but adds ongoing hidden costs:

*   Time spent on ops
*   Downtime risk
*   Security responsibilities
*   Scaling complexity

Juno uses simple usage-based pricing for compute and storage. No machines to maintain, no surprise maintenance time, no infrastructure overhead.

---

## When Juno Makes the Most Sense

**Best fit for developers who want:**

*   Self-host-level control without running servers
*   A private, isolated execution environment
*   Built-in authentication, database, and storage
*   Production-grade reliability without ops work

**Self-hosting still fits when:**

*   You enjoy running servers
*   You need bare-metal control
*   You want to manage every layer yourself

---

## The takeaway

Self-hosting gives you freedom â€” and a lot of maintenance.

Juno gives you the same ownership and control, but lets you focus entirely on building rather than operating infrastructure.

If you want the privacy and autonomy of running your own server, without becoming your own DevOps team, Juno is the modern alternative.

---

## Ready to try Juno?

Ready to explore Juno? [Start building](/docs/intro.md)

# What makes Juno a great Vercel alternative

Vercel has been a default choice for frontend teams building with Next.js. It's fast, convenient, and delivers a world-class developer experience. For teams prioritizing raw speed and integration with the centralized cloud ecosystem, Vercel is the established leader.

But what if you need more than just speed? What if you need true ownership, control over your infrastructure, and a platform that won't lock you in?

This is where Juno steps in. It's an open-source serverless platform to build, deploy, and run modern apps with the privacy and control of self-hosting â€” without the infrastructure headache.

---

## The Trade-Off: Convenience vs. Control

Vercel's strength lies in its managed infrastructure. It handles everything, but that convenience comes at a cost: your application is entirely dependent on their commercial policies and centralized infrastructure.

Juno flips this model. It provides a similar seamless developer experience but gives you your own self-contained execution space. This architectural difference is the key benefit for developers:

*   **Your Own Infrastructure**: Your application runs in a container you own and control â€” with zero DevOps burden. Juno has zero access to your code, data, or infrastructure. Everything runs under your ownership.
*   **Unstoppable Execution**: Deployed to a network of independent nodes operated by different providers worldwide, making it resistant to censorship, unexpected downtime, and single points of failure.

---

## Feature Breakdown: Vercel's Speed vs. Juno's Stack

| Feature | Vercel (Centralized Speed) | Juno (Decentralized Control) |
| --- | --- | --- |
| Deployment | Global CDN (Centralized Cloud) | Decentralized Containers (Unstoppable) |
| Serverless Functions | Edge Functions (Fast, Centralized) | Rust/TypeScript Functions (Owned, Decentralized) |
| Authentication | External Services Required | Built-in Decentralized Auth (Privacy-First) |
| Datastore | External Services Required | Built-in Decentralized Datastore (Owned Data) |
| File Storage | External Services Required | Built-in Decentralized Storage |
| Core Benefit | Speed, Convenience, Established Ecosystem | Ownership, Privacy, Integrated Full Stack |

---

## Cost Advantage: Predictable Ownership vs. Escalating Bills

Vercel offers a generous free tier â€” but its pricing scales quickly and often unpredictably as your traffic grows. Bandwidth overages and function execution costs can lead to surprise bills as your application succeeds.

Juno offers predictable, usage-based pricing with transparent costs for compute and storage. You pay for what you use like a utility, with no surprise bandwidth charges or vendor lock-in premiums. This creates cost efficiency and financial stability for growing apps.

---

## Beyond Hosting: A Full-Stack Advantage

Vercel excels at frontend deployment, but often requires you to stitch together external services for a complete application â€” databases, file storage, functions, and more.

Juno integrates these natively:

*   **Built-in Data & Storage** â€” Store app state and user-generated content without managing external services.
*   **Serverless Functions** â€” Write backend logic in Rust or TypeScript and deploy alongside your frontend.
*   **Familiar Developer Workflow** â€” Works with React, Next.js (static export), SvelteKit (static), Astro, Vue, and more.

The result: modern serverless development in your own self-contained execution space â€” the privacy and control of self-hosting without the operational overhead.

---

## Performance Considerations

Juno's decentralized network is optimized for web-speed delivery with nodes distributed globally. While Vercel's edge network is highly optimized for raw speed, Juno delivers competitive performance with the added benefit of resilience and data sovereignty.

For applications where sub-50ms response times are critical (like real-time collaborative tools), Vercel's edge infrastructure may have an advantage. For most web applications, Juno provides excellent performance while giving you full ownership of your stack.

---

## What You Should Know

Juno represents a different approach to web infrastructure. Here's what to consider:

**Best fit for:**

*   Projects requiring data sovereignty and user-owned data
*   Privacy-focused applications where you don't want to depend on centralized providers
*   Long-term projects where you want infrastructure independence
*   Applications needing censorship resistance or unstoppable availability

**Trade-offs to consider:**

*   Smaller (but growing) ecosystem compared to Vercel's mature marketplace
*   No server-side rendering (SSR) support â€” Juno is optimized for static sites and client-side applications

**Migration path:**

Juno supports standard web frameworks, making it straightforward to port existing applications. Many teams start with a proof of concept to explore the platform â€” getting started is free, so you can experiment without commitment before deciding to migrate.

---

## The Right Choice for Your Project

If you're building a simple marketing site and need maximum speed with a large ecosystem of integrations, Vercel remains a strong choice.

But if your application demands:

*   **Your own infrastructure** without DevOps overhead
*   **Full-stack services you control** (auth, data, storage, compute)
*   **Privacy and ownership** â€” Juno has zero access to your code or data
*   **Open-source, unstoppable execution**

Then **Juno is a powerful Vercel alternative** â€” the same serverless experience developers love, with actual ownership and control over your application.

---

## Ready to try Juno?

Ready to explore Juno? [Start building](/docs/intro.md)

# Frontend

Build full apps with Juno using your preferred frontend framework. These examples cover everything from auth to data handling with React, SvelteKit, Angular, Next.js, and more.

[## ðŸ“„ï¸ Next.js

A fullstack note-taking app built with Next.js, and Tailwind CSS using Juno for authentication, data, and file storage.](/docs/examples/frontend/nextjs.md)

[## ðŸ“„ï¸ React TypeScript

A fullstack note-taking app built with React, TypeScript, and Tailwind CSS using Juno for authentication, data, and file storage.](/docs/examples/frontend/react-typescript.md)

[## ðŸ“„ï¸ React JavaScript

A fullstack note-taking app built with React, JavaScript, and Tailwind CSS using Juno for authentication, data, and file storage.](/docs/examples/frontend/react-javascript.md)

[## ðŸ“„ï¸ Vue

A fullstack note-taking app built with Vue, and Tailwind CSS using Juno for authentication, data, and file storage.](/docs/examples/frontend/vue.md)

[## ðŸ“„ï¸ SvelteKit

A fullstack note-taking app built with SvelteKit, and Tailwind CSS using Juno for authentication, data, and file storage.](/docs/examples/frontend/sveltekit.md)

[## ðŸ“„ï¸ Angular

A fullstack note-taking app built with Angular, and Tailwind CSS using Juno for authentication, data, and file storage.](/docs/examples/frontend/angular.md)

[## ðŸ“„ï¸ Vanilla JavaScript

A fullstack note-taking app built with vanilla JavaScript, and Tailwind CSS using Juno for authentication, data, and file storage.](/docs/examples/frontend/vanilla-javascript.md)

# Functions

Write serverless backend logic for your app using TypeScript or Rust. These examples show how to use hooks, assertions, and common function patterns on Juno.

[## ðŸ—ƒï¸ Rust

4 items](/docs/examples/functions/rust.md)

[## ðŸ—ƒï¸ TypeScript

3 items](/docs/examples/functions/typescript.md)

# Angular Example

This project is a note-taking app template built with **Angular**, **TypeScript**, and **Tailwind CSS**, designed to demonstrate integration with Juno for app development. It showcases authentication, data storage, and file storage using Juno's Satellite container.

You can scaffold it using the following command, or browse the source code:

```
npm create juno@latest -- --template angular-example
```

Source: [github.com/junobuild/create-juno/templates/angular-example](https://github.com/junobuild/create-juno/tree/main/templates/angular-example)

---

## Folder Structure

```
angular-example/â”œâ”€â”€ public/                # Static assetsâ”œâ”€â”€ src/â”‚   â”œâ”€â”€ app/               # Angular modules, components, services, and typesâ”‚   â”œâ”€â”€ environments/      # Environment configuration filesâ”‚   â”œâ”€â”€ styles.css         # Tailwind CSS stylesâ”‚   â””â”€â”€ main.ts            # Angular entry pointâ”œâ”€â”€ juno.config.mjs        # Juno Satellite configurationâ”œâ”€â”€ package.json           # Project dependencies and scriptsâ”œâ”€â”€ angular.json           # Angular CLI configurationâ”œâ”€â”€ README.md              # User-facing documentationâ””â”€â”€ ...                    # Other config and build files
```

---

## Key Features

*   **Juno Integration**: Uses Juno's Satellite for authentication, Datastore, and Storage.
*   **Authentication**: Login/logout flow.
*   **Notes Collection**: Users can create, view, and delete notes (text, with optional file URL).
*   **Images Collection**: Supports file storage for images.
*   **Responsive UI**: Built with Tailwind CSS for modern styling.
*   **Banner**: Warns if the Satellite is not configured for local development.

---

## Main Components

*   **app.component.ts**: Main Angular component, bootstraps the app and layout.
*   **components/**: Contains UI and logic for authentication, notes table, modal, banner, etc.
*   **services/**: Angular services for interacting with Juno and managing app state.
*   **types/note.ts**: TypeScript interface for notes.

---

## Data Structure

*   **Note** (`src/app/types/note.ts`):
    
    ```
    export interface Note {  text: string;  url?: string;}
    ```
    

---

## How to Run

. **Install dependencies**:

```
npm install
```

NaN. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

3.  **Create a Satellite** for local dev:
    *   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
    *   Update `src/environments/environment.ts` with your Satellite ID.

4.  **Create required collections**:

*   `notes` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)
*   `images` in Storage: [http://localhost:5866/storage](http://localhost:5866/storage)

5.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

---

## Juno-Specific Configuration

*   **juno.config.mjs**: Defines Satellite IDs for development/production, build source, and predeploy steps. See the [Configuration reference](/docs/reference/configuration.md) for details.
*   **src/environments/environment.ts**: Contains the Satellite ID for local development.
*   **src/environments/environment.prod.ts**: Contains the Satellite ID for production.

---

## Production Deployment

*   Create a Satellite on the [Juno Console](https://console.juno.build) for mainnet.
*   Update `src/environments/environment.prod.ts` and `juno.config.mjs` with the production Satellite ID.
*   Build and deploy:

```
npm run buildjuno hosting deploy
```

---

## Notes

*   The app is intended as a starting point for Juno-based projects.
*   All logic is in TypeScript and Angular components/services.
*   The app is fully client-side (Server Side Rendering is not supported yet) and interacts with Juno via the Satellite container.

---

## Juno SDK Used

The following functions from `@junobuild/core` are used in this example:

| Function | Purpose/Description | Where Used (File/Component) | Juno Docs/Source Reference |
| --- | --- | --- | --- |
| `initSatellite` | Initialize Juno Satellite container | [`src/app/app.component.ts`](https://github.com/junobuild/create-juno/blob/main/templates/angular-example/src/app/app.component.ts) | [Initialization](/docs/setup-the-sdk.md#initialization) |
| `onAuthStateChange` | Subscribe to auth state changes | [`src/app/services/auth.service.ts`](https://github.com/junobuild/create-juno/blob/main/templates/angular-example/src/app/services/auth.service.ts) | [Listening to Auth Changes](/docs/build/authentication/utilities.md#listening-to-auth-changes) |
| `signIn` | Sign in user | [`src/app/components/login/login.component.ts`](https://github.com/junobuild/create-juno/blob/main/templates/angular-example/src/app/components/login/login.component.ts) | [Sign-in](/docs/build/authentication/internet-identity.md#sign-in) |
| `signOut` | Sign out user | [`src/app/components/logout/logout.component.ts`](https://github.com/junobuild/create-juno/blob/main/templates/angular-example/src/app/components/logout/logout.component.ts) | [Sign-out](/docs/build/authentication/utilities.md#sign-out) |
| `listDocs` | List documents in a collection | [`src/app/services/docs.service.ts`](https://github.com/junobuild/create-juno/blob/main/templates/angular-example/src/app/services/docs.service.ts) | [List documents](/docs/build/datastore/development.md#list-documents) |
| `setDoc` | Create or update a document | [`src/app/components/modal/modal.component.ts`](https://github.com/junobuild/create-juno/blob/main/templates/angular-example/src/app/components/modal/modal.component.ts) | [Add a document](/docs/build/datastore/development.md#add-a-document) |
| `deleteDoc` | Delete a document | [`src/app/components/delete/delete.component.ts`](https://github.com/junobuild/create-juno/blob/main/templates/angular-example/src/app/components/delete/delete.component.ts) | [Delete a document](/docs/build/datastore/development.md#delete-a-document) |
| `uploadFile` | Upload a file to storage | [`src/app/components/modal/modal.component.ts`](https://github.com/junobuild/create-juno/blob/main/templates/angular-example/src/app/components/modal/modal.component.ts) | [Upload file](/docs/build/storage/development.md#upload-file) |
| `deleteAsset` | Delete a file from storage | [`src/app/components/delete/delete.component.ts`](https://github.com/junobuild/create-juno/blob/main/templates/angular-example/src/app/components/delete/delete.component.ts) | [Delete asset](/docs/build/storage/development.md#delete-asset) |

# Next.js Example

This project is a note-taking app template built with **Next.js**, **TypeScript**, and **Tailwind CSS**, designed to demonstrate integration with Juno for app development. It showcases authentication, data storage, and file storage using Juno's Satellite container.

You can scaffold it using the following command, or browse the source code:

```
npm create juno@latest -- --template nextjs-example
```

Source: [github.com/junobuild/create-juno/templates/nextjs-example](https://github.com/junobuild/create-juno/tree/main/templates/nextjs-example)

---

## Folder Structure

```
nextjs-example/â”œâ”€â”€ public/                # Static assetsâ”œâ”€â”€ src/â”‚   â”œâ”€â”€ app/               # Next.js app directory (routing, layout, etc.)â”‚   â”œâ”€â”€ components/        # React UI components (auth, table, modal, banner, etc.)â”‚   â”œâ”€â”€ types/             # TypeScript types (e.g., note.ts)â”œâ”€â”€ juno.config.mjs        # Juno Satellite configurationâ”œâ”€â”€ package.json           # Project dependencies and scriptsâ”œâ”€â”€ next.config.mjs        # Next.js configurationâ”œâ”€â”€ README.md              # User-facing documentationâ””â”€â”€ ...                    # Other config and build files
```

---

## Key Features

*   **Juno Integration**: Uses Juno's Satellite for authentication, Datastore, and Storage.
*   **Authentication**: Login/logout flow.
*   **Notes Collection**: Users can create, view, and delete notes (text, with optional file URL).
*   **Images Collection**: Supports file storage for images.
*   **Responsive UI**: Built with Tailwind CSS for modern styling.
*   **Banner**: Warns if the Satellite is not configured for local development.

---

## Main Components

*   **src/app/**: Next.js app directory, handles routing and layout.
*   **components/**: Contains UI and logic for authentication, notes table, modal, banner, etc.
*   **types/note.ts**: TypeScript interface for notes.

---

## Data Structure

*   **NoteData** (`src/types/note.ts`):

```
export interface NoteData {  text: string;  url?: string;}export type Note = Doc<NoteData>;
```

---

## How to Run

. **Install dependencies**:

```
npm install
```

NaN. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

3. **Create a Satellite** for local dev:

*   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
*   Update `juno.config.mjs` with your Satellite ID.

4.  **Create required collections**:

*   `notes` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)
*   `images` in Storage: [http://localhost:5866/storage](http://localhost:5866/storage)

5.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

---

## Juno-Specific Configuration

*   `juno.config.mjs`: Defines Satellite IDs for development/production, build source, and predeploy steps. See the [Configuration reference](/docs/reference/configuration.md) for details.
*   `next.config.mjs`: Uses the `withJuno` plugin to load environment variables and inject config automatically at build time. See the [Next.js Plugin reference](/docs/reference/plugins.md#nextjs-plugin) for more information.

---

## Production Deployment

*   Create a Satellite on the [Juno Console](https://console.juno.build) for mainnet.
*   Update `juno.config.mjs` with the production Satellite ID.
*   Build and deploy:

```
npm run buildjuno hosting deploy
```

---

## Notes

*   The app is intended as a starting point for Juno-based projects.
*   All logic is in TypeScript and React function components.
*   The app is fully client-side (Server Side Rendering is not supported yet) and interacts with Juno via the Satellite container.

---

## Juno SDK Used

The following functions from `@junobuild/core` are used in this example:

| Function | Purpose/Description | Where Used (File/Component) | Juno Docs/Source Reference |
| --- | --- | --- | --- |
| `initSatellite` | Initialize Juno Satellite container | [`src/app/page.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/nextjs-example/src/app/page.tsx) | [Initialization](/docs/setup-the-sdk.md#initialization) |
| `onAuthStateChange` | Subscribe to auth state changes | [`src/components/auth.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/nextjs-example/src/components/auth.tsx) | [Listening to Auth Changes](/docs/build/authentication/utilities.md#listening-to-auth-changes) |
| `signIn` | Sign in user | [`src/components/login.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/nextjs-example/src/components/login.tsx) | [Sign-in](/docs/build/authentication/internet-identity.md#sign-in) |
| `signOut` | Sign out user | [`src/components/logout.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/nextjs-example/src/components/logout.tsx) | [Sign-out](/docs/build/authentication/utilities.md#sign-out) |
| `listDocs` | List documents in a collection | [`src/components/table.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/nextjs-example/src/components/table.tsx) | [List documents](/docs/build/datastore/development.md#list-documents) |
| `setDoc` | Create or update a document | [`src/components/modal.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/nextjs-example/src/components/modal.tsx) | [Add a document](/docs/build/datastore/development.md#add-a-document) |
| `deleteDoc` | Delete a document | [`src/components/delete.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/nextjs-example/src/components/delete.tsx) | [Delete a document](/docs/build/datastore/development.md#delete-a-document) |
| `uploadFile` | Upload a file to storage | [`src/components/modal.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/nextjs-example/src/components/modal.tsx) | [Upload file](/docs/build/storage/development.md#upload-file) |
| `deleteAsset` | Delete a file from storage | [`src/components/delete.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/nextjs-example/src/components/delete.tsx) | [Delete asset](/docs/build/storage/development.md#delete-asset) |

# React JavaScript Example

This project is a note-taking app template built with **React**, **JavaScript**, and **Tailwind CSS**, designed to demonstrate integration with Juno for app development. It showcases authentication, data storage, and file storage using Juno's Satellite container.

You can scaffold it using the following command, or browse the source code:

```
npm create juno@latest -- --template react-example
```

Source: [github.com/junobuild/create-juno/templates/react-example](https://github.com/junobuild/create-juno/tree/main/templates/react-example)

---

## Folder Structure

```
react-example/â”œâ”€â”€ public/                # Static assetsâ”œâ”€â”€ src/â”‚   â”œâ”€â”€ components/        # React UI components (Auth, Table, Modal, Banner, etc.)â”‚   â”œâ”€â”€ App.jsx            # Main app componentâ”‚   â”œâ”€â”€ main.jsx           # React entry pointâ”‚   â””â”€â”€ index.css          # Tailwind CSS stylesâ”œâ”€â”€ juno.config.mjs        # Juno Satellite configurationâ”œâ”€â”€ package.json           # Project dependencies and scriptsâ”œâ”€â”€ vite.config.js         # Vite build configurationâ”œâ”€â”€ README.md              # User-facing documentationâ””â”€â”€ ...                    # Other config and build files
```

---

## Key Features

*   **Juno Integration**: Uses Juno's Satellite for authentication, Datastore, and Storage.
*   **Authentication**: Login/logout flow.
*   **Notes Collection**: Users can create, view, and delete notes (text, with optional file URL).
*   **Images Collection**: Supports file storage for images.
*   **Responsive UI**: Built with Tailwind CSS for modern styling.
*   **Banner**: Warns if the Satellite is not configured for local development.

---

## Main Components

*   **App.jsx**: Initializes Juno Satellite, renders the main layout, and wraps content in authentication.
*   **Banner.jsx**: Shows a warning if the Satellite ID is missing in local dev.
*   **Auth.jsx**: Provides authentication context and login/logout UI.
*   **Table.jsx**: Displays the list of notes from the Datastore.
*   **Modal.jsx**: Handles note creation and editing.
*   **Delete.jsx**: Handles note deletion.
*   **Footer.jsx, Background.jsx, Button.jsx, etc.**: UI and utility components.

---

## Data Structure

*   **Note** (used in Table.jsx):

```
// Example note object{  key: string,  data: {    text: string,    url?: string  }}
```

---

## How to Run

. **Install dependencies**:

```
npm install
```

NaN. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

3. **Create a Satellite** for local dev:

*   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
*   Update `juno.config.mjs` with your Satellite ID.

4.  **Create required collections**:

*   `notes` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)
*   `images` in Storage: [http://localhost:5866/storage](http://localhost:5866/storage)

5.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

---

## Juno-Specific Configuration

*   **juno.config.mjs**: Defines Satellite IDs for development/production, build source, and predeploy steps. See the [Configuration reference](/docs/reference/configuration.md) for details.
*   **vite.config.js**: Registers the `juno` plugin to inject environment variables automatically. See the [Vite Plugin reference](/docs/reference/plugins.md#vite-plugin) for more information.

---

## Production Deployment

*   Create a Satellite on the [Juno Console](https://console.juno.build) for mainnet.
*   Update `juno.config.mjs` with the production Satellite ID.
*   Build and deploy:

```
npm run buildjuno hosting deploy
```

---

## Notes

*   The app is intended as a starting point for Juno-based projects.
*   All logic is in JavaScript and React function components.
*   The app is fully client-side (Server Side Rendering is not supported yet) and interacts with Juno via the Satellite container.

---

## Juno SDK Used

The following functions from `@junobuild/core` are used in this example:

| Function | Purpose/Description | Where Used (File/Component) | Juno Docs/Source Reference |
| --- | --- | --- | --- |
| `initSatellite` | Initialize Juno Satellite container | [`src/App.jsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-example/src/App.jsx) | [Initialization](/docs/setup-the-sdk.md#initialization) |
| `onAuthStateChange` | Subscribe to auth state changes | [`src/components/Auth.jsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-example/src/components/Auth.jsx) | [Listening to Auth Changes](/docs/build/authentication/utilities.md#listening-to-auth-changes) |
| `signIn` | Sign in user | [`src/components/Login.jsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-example/src/components/Login.jsx) | [Sign-in](/docs/build/authentication/internet-identity.md#sign-in) |
| `signOut` | Sign out user | [`src/components/Logout.jsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-example/src/components/Logout.jsx) | [Sign-out](/docs/build/authentication/utilities.md#sign-out) |
| `listDocs` | List documents in a collection | [`src/components/Table.jsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-example/src/components/Table.jsx) | [List documents](/docs/build/datastore/development.md#list-documents) |
| `setDoc` | Create or update a document | [`src/components/Modal.jsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-example/src/components/Modal.jsx) | [Add a document](/docs/build/datastore/development.md#add-a-document) |
| `deleteDoc` | Delete a document | [`src/components/Delete.jsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-example/src/components/Delete.jsx) | [Delete a document](/docs/build/datastore/development.md#delete-a-document) |
| `uploadFile` | Upload a file to storage | [`src/components/Modal.jsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-example/src/components/Modal.jsx) | [Upload file](/docs/build/storage/development.md#upload-file) |
| `deleteAsset` | Delete a file from storage | [`src/components/Delete.jsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-example/src/components/Delete.jsx) | [Delete asset](/docs/build/storage/development.md#delete-asset) |

# React TypeScript Example

This project is a note-taking app template built with **React**, **TypeScript**, and **Tailwind CSS**, designed to demonstrate integration with Juno for app development. It showcases authentication, data storage, and file storage using Juno's Satellite container.

You can scaffold it using the following command, or browse the source code:

```
npm create juno@latest -- --template react-ts-example
```

Source: [github.com/junobuild/create-juno/templates/react-ts-example](https://github.com/junobuild/create-juno/tree/main/templates/react-ts-example)

---

## Folder Structure

```
react-ts-example/â”œâ”€â”€ public/                # Static assetsâ”œâ”€â”€ src/â”‚   â”œâ”€â”€ components/        # React UI components (Auth, Table, Modal, Banner, etc.)â”‚   â”œâ”€â”€ types/             # TypeScript types (e.g., note.ts)â”‚   â”œâ”€â”€ App.tsx            # Main app componentâ”‚   â”œâ”€â”€ main.tsx           # React entry pointâ”‚   â””â”€â”€ index.css          # Tailwind CSS stylesâ”œâ”€â”€ juno.config.ts         # Juno Satellite configurationâ”œâ”€â”€ package.json           # Project dependencies and scriptsâ”œâ”€â”€ vite.config.ts         # Vite build configurationâ”œâ”€â”€ README.md              # User-facing documentationâ””â”€â”€ ...                    # Other config and build files
```

---

## Key Features

*   **Juno Integration**: Uses Juno's Satellite for authentication, Datastore, and Storage.
*   **Authentication**: Login/logout flow.
*   **Notes Collection**: Users can create, view, and delete notes (text, with optional file URL).
*   **Images Collection**: Supports file storage for images.
*   **Responsive UI**: Built with Tailwind CSS for modern styling.
*   **Banner**: Warns if the Satellite is not configured for local development.

---

## Main Components

*   **App.tsx**: Initializes Juno Satellite, renders the main layout, and wraps content in authentication.
*   **Banner.tsx**: Shows a warning if the Satellite ID is missing in local dev.
*   **Auth.tsx**: Provides authentication context and login/logout UI.
*   **Table.tsx**: Displays the list of notes from the Datastore.
*   **Modal.tsx**: Handles note creation and editing.
*   **Delete.tsx**: Handles note deletion.
*   **Footer.tsx, Background.tsx, Button.tsx, etc.**: UI and utility components.

---

## Data Types

*   **NoteData** (`src/types/note.ts`):

```
export interface NoteData {  text: string;  url?: string;}export type Note = Doc<NoteData>;
```

---

## How to Run

. **Install dependencies**:

```
npm install
```

NaN. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

3. **Create a Satellite** for local dev:

*   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
*   Update `juno.config.ts` with your Satellite ID.

4.  **Create required collections**:

*   `notes` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)
*   `images` in Storage: [http://localhost:5866/storage](http://localhost:5866/storage)

5.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

---

## Juno-Specific Configuration

*   **juno.config.ts**: Defines Satellite IDs for development/production, build source, and predeploy steps. See the [Configuration reference](/docs/reference/configuration.md) for details.
*   **vite.config.ts**: Registers the `juno` plugin to inject environment variables automatically. See the [Vite Plugin reference](/docs/reference/plugins.md#vite-plugin) for more information.

---

## Production Deployment

*   Create a Satellite on the [Juno Console](https://console.juno.build) for mainnet.
*   Update with the production Satellite ID.
*   Build and deploy:

```
npm run buildjuno hosting deploy
```

---

## Notes

*   The app is intended as a starting point for Juno-based projects.
*   All logic is in JavaScript and React function components.
*   The app is fully client-side (Server Side Rendering is not supported yet) and interacts with Juno via the Satellite container.

---

## Juno SDK Used

The following functions from `@junobuild/core` are used in this example:

| Function | Purpose/Description | Where Used (File/Component) | Juno Docs/Source Reference |
| --- | --- | --- | --- |
| `initSatellite` | Initialize Juno Satellite container | [`src/App.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-ts-example/src/App.tsx) | [Initialization](/docs/setup-the-sdk.md#initialization) |
| `onAuthStateChange` | Subscribe to auth state changes | [`src/components/Auth.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-ts-example/src/components/Auth.tsx) | [Listening to Auth Changes](/docs/build/authentication/utilities.md#listening-to-auth-changes) |
| `signIn` | Sign in user | [`src/components/Login.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-ts-example/src/components/Login.tsx) | [Sign-in](/docs/build/authentication/internet-identity.md#sign-in) |
| `signOut` | Sign out user | [`src/components/Logout.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-ts-example/src/components/Logout.tsx) | [Sign-out](/docs/build/authentication/utilities.md#sign-out) |
| `listDocs` | List documents in a collection | [`src/components/Table.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-ts-example/src/components/Table.tsx) | [List documents](/docs/build/datastore/development.md#list-documents) |
| `setDoc` | Create or update a document | [`src/components/Modal.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-ts-example/src/components/Modal.tsx) | [Add a document](/docs/build/datastore/development.md#add-a-document) |
| `deleteDoc` | Delete a document | [`src/components/Delete.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-ts-example/src/components/Delete.tsx) | [Delete a document](/docs/build/datastore/development.md#delete-a-document) |
| `uploadFile` | Upload a file to storage | [`src/components/Modal.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-ts-example/src/components/Modal.tsx) | [Upload file](/docs/build/storage/development.md#upload-file) |
| `deleteAsset` | Delete a file from storage | [`src/components/Delete.tsx`](https://github.com/junobuild/create-juno/blob/main/templates/react-ts-example/src/components/Delete.tsx) | [Delete asset](/docs/build/storage/development.md#delete-asset) |

# SvelteKit Example

This project is a note-taking app template built with **SvelteKit**, **TypeScript**, and **Tailwind CSS**, designed to demonstrate integration with Juno for app development. It showcases authentication, data storage, and file storage using Juno's Satellite container.

You can scaffold it using the following command, or browse the source code:

```
npm create juno@latest -- --template sveltekit-example
```

Source: [github.com/junobuild/create-juno/templates/sveltekit-example](https://github.com/junobuild/create-juno/tree/main/templates/sveltekit-example)

---

## Folder Structure

```
sveltekit-example/â”œâ”€â”€ static/                # Static assetsâ”œâ”€â”€ src/â”‚   â”œâ”€â”€ lib/               # SvelteKit components, stores, types, etc.â”‚   â”œâ”€â”€ routes/            # SvelteKit routes and layoutsâ”‚   â”œâ”€â”€ app.css            # Tailwind CSS stylesâ”‚   â””â”€â”€ app.html           # SvelteKit HTML templateâ”œâ”€â”€ juno.config.ts         # Juno Satellite configurationâ”œâ”€â”€ package.json           # Project dependencies and scriptsâ”œâ”€â”€ vite.config.ts         # Vite build configurationâ”œâ”€â”€ README.md              # User-facing documentationâ””â”€â”€ ...                    # Other config and build files
```

---

## Key Features

*   **Juno Integration**: Uses Juno's Satellite for authentication, Datastore, and Storage.
*   **Authentication**: Login/logout flow.
*   **Notes Collection**: Users can create, view, and delete notes (text, with optional file URL).
*   **Images Collection**: Supports file storage for images.
*   **Responsive UI**: Built with Tailwind CSS for modern styling.
*   **Banner**: Warns if the Satellite is not configured for local development.

---

## Main Components

*   **src/routes/+layout.svelte**: Main layout, initializes Juno Satellite, wraps content in authentication.
*   **lib/components/**: Contains UI and logic for authentication, notes table, modal, banner, etc.
*   **lib/types/note.ts**: TypeScript interface for notes.
*   **lib/types/user.ts**: TypeScript interface for user.

---

## Data Structure

*   **Note** (`src/lib/types/note.ts`):

```
export interface Note {  text: string;  url?: string;}
```

---

## How to Run

. **Install dependencies**:

```
npm install
```

NaN. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

3. **Create a Satellite** for local dev:

*   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
*   Update `juno.config.ts` with your Satellite ID.

4.  **Create required collections**:

*   `notes` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)
*   `images` in Storage: [http://localhost:5866/storage](http://localhost:5866/storage)

5.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

---

## Juno-Specific Configuration

*   **juno.config.ts**: Defines Satellite IDs for development/production, build source, and predeploy steps. See the [Configuration reference](/docs/reference/configuration.md) for details.
*   **vite.config.ts**: Registers the `juno` plugin to inject environment variables automatically. See the [Vite Plugin reference](/docs/reference/plugins.md#vite-plugin) for more information.

---

## Production Deployment

*   Create a Satellite on the [Juno Console](https://console.juno.build) for mainnet.
*   Update with the production Satellite ID.
*   Build and deploy:

```
npm run buildjuno hosting deploy
```

---

## Notes

*   The app is intended as a starting point for Juno-based projects.
*   All logic is in TypeScript and SvelteKit components/stores.
*   The app is fully client-side (Server Side Rendering is not supported yet) and interacts with Juno via the Satellite container.

---

## Juno SDK Used

The following functions from `@junobuild/core` are used in this example:

| Function | Purpose/Description | Where Used (File/Component) | Juno Docs/Source Reference |
| --- | --- | --- | --- |
| `initSatellite` | Initialize Juno Satellite container | [`src/routes/+layout.svelte`](https://github.com/junobuild/create-juno/blob/main/templates/sveltekit-example/src/routes/+layout.svelte) | [Initialization](/docs/setup-the-sdk.md#initialization) |
| `onAuthStateChange` | Subscribe to auth state changes | [`src/lib/components/Auth.svelte`](https://github.com/junobuild/create-juno/blob/main/templates/sveltekit-example/src/lib/components/Auth.svelte) | [Listening to Auth Changes](/docs/build/authentication/utilities.md#listening-to-auth-changes) |
| `signIn` | Sign in user | [`src/lib/components/Login.svelte`](https://github.com/junobuild/create-juno/blob/main/templates/sveltekit-example/src/lib/components/Login.svelte) | [Sign-in](/docs/build/authentication/internet-identity.md#sign-in) |
| `signOut` | Sign out user | [`src/lib/components/Logout.svelte`](https://github.com/junobuild/create-juno/blob/main/templates/sveltekit-example/src/lib/components/Logout.svelte) | [Sign-out](/docs/build/authentication/utilities.md#sign-out) |
| `listDocs` | List documents in a collection | [`src/lib/components/Table.svelte`](https://github.com/junobuild/create-juno/blob/main/templates/sveltekit-example/src/lib/components/Table.svelte) | [List documents](/docs/build/datastore/development.md#list-documents) |
| `setDoc` | Create or update a document | [`src/lib/components/Modal.svelte`](https://github.com/junobuild/create-juno/blob/main/templates/sveltekit-example/src/lib/components/Modal.svelte) | [Add a document](/docs/build/datastore/development.md#add-a-document) |
| `deleteDoc` | Delete a document | [`src/lib/components/Delete.svelte`](https://github.com/junobuild/create-juno/blob/main/templates/sveltekit-example/src/lib/components/Delete.svelte) | [Delete a document](/docs/build/datastore/development.md#delete-a-document) |
| `uploadFile` | Upload a file to storage | [`src/lib/components/Modal.svelte`](https://github.com/junobuild/create-juno/blob/main/templates/sveltekit-example/src/lib/components/Modal.svelte) | [Upload file](/docs/build/storage/development.md#upload-file) |
| `deleteAsset` | Delete a file from storage | [`src/lib/components/Delete.svelte`](https://github.com/junobuild/create-juno/blob/main/templates/sveltekit-example/src/lib/components/Delete.svelte) | [Delete asset](/docs/build/storage/development.md#delete-asset) |

# Vanilla JavaScript Example

This project is a note-taking app template built with **vanilla JavaScript** and **Tailwind CSS**, designed to demonstrate integration with Juno for app development. It showcases authentication, data storage, and file storage using Juno's Satellite container.

You can scaffold it using the following command, or browse the source code:

```
npm create juno@latest -- --template vanilla-js-example
```

Source: [github.com/junobuild/create-juno/templates/vanilla-js-example](https://github.com/junobuild/create-juno/tree/main/templates/vanilla-js-example)

---

## Folder Structure

```
vanilla-js-example/â”œâ”€â”€ public/                # Static assetsâ”œâ”€â”€ src/â”‚   â”œâ”€â”€ components/        # JS UI components (auth, table, modal, banner, etc.)â”‚   â”œâ”€â”€ main.js            # Main entry pointâ”‚   â””â”€â”€ style.css          # Tailwind CSS stylesâ”œâ”€â”€ juno.config.mjs        # Juno Satellite configurationâ”œâ”€â”€ package.json           # Project dependencies and scriptsâ”œâ”€â”€ vite.config.js         # Vite build configurationâ”œâ”€â”€ README.md              # User-facing documentationâ””â”€â”€ ...                    # Other config and build files
```

---

## Key Features

*   **Juno Integration**: Uses Juno's Satellite for authentication, Datastore, and Storage.
*   **Authentication**: Login/logout flow.
*   **Notes Collection**: Users can create, view, and delete notes (text, with optional file URL).
*   **Images Collection**: Supports file storage for images.
*   **Responsive UI**: Built with Tailwind CSS for modern styling.
*   **Banner**: Warns if the Satellite is not configured for local development.

---

## Main Components

*   **src/main.js**: Main entry point, initializes Juno Satellite, handles authentication state.
*   **components/**: Contains UI and logic for authentication, notes table, modal, banner, etc.

---

## Data Structure

*   **Note** (used in table.js, modal.js, etc.):

```
// Example note object{  key: string,  data: {    text: string,    url?: string  }}
```

---

## How to Run

. **Install dependencies**:

```
npm install
```

NaN. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

3. **Create a Satellite** for local dev:

*   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
*   Update `juno.config.mjs` with your Satellite ID.

4.  **Create required collections**:

*   `notes` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)
*   `images` in Storage: [http://localhost:5866/storage](http://localhost:5866/storage)

5.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

---

## Juno-Specific Configuration

*   **juno.config.mjs**: Defines Satellite IDs for development/production, build source, and predeploy steps. See the [Configuration reference](/docs/reference/configuration.md) for details.
*   **vite.config.js**: Registers the `juno` plugin to inject environment variables automatically. See the [Vite Plugin reference](/docs/reference/plugins.md#vite-plugin) for more information.

---

## Production Deployment

*   Create a Satellite on the [Juno Console](https://console.juno.build) for mainnet.
*   Update `juno.config.mjs` with the production Satellite ID.
*   Build and deploy:

```
npm run buildjuno hosting deploy
```

---

## Notes

*   The app is intended as a starting point for Juno-based projects.
*   All logic is in vanilla JavaScript modules.
*   The app is fully client-side (Server Side Rendering is not supported yet) and interacts with Juno via the Satellite container.

---

## Juno SDK Used

The following functions from `@junobuild/core` are used in this example:

| Function | Purpose/Description | Where Used (File/Component) | Juno Docs/Source Reference |
| --- | --- | --- | --- |
| `initSatellite` | Initialize Juno Satellite container | [`src/main.js`](https://github.com/junobuild/create-juno/blob/main/templates/vanilla-js-example/src/main.js) | [Initialization](/docs/setup-the-sdk.md#initialization) |
| `onAuthStateChange` | Subscribe to auth state changes | [`src/main.js`](https://github.com/junobuild/create-juno/blob/main/templates/vanilla-js-example/src/main.js), [`src/components/modal.js`](https://github.com/junobuild/create-juno/blob/main/templates/vanilla-js-example/src/components/modal.js) | [Listening to Auth Changes](/docs/build/authentication/utilities.md#listening-to-auth-changes) |
| `signIn` | Sign in user | [`src/components/login.js`](https://github.com/junobuild/create-juno/blob/main/templates/vanilla-js-example/src/components/login.js) | [Sign-in](/docs/build/authentication/internet-identity.md#sign-in) |
| `signOut` | Sign out user | [`src/components/logout.js`](https://github.com/junobuild/create-juno/blob/main/templates/vanilla-js-example/src/components/logout.js) | [Sign-out](/docs/build/authentication/utilities.md#sign-out) |
| `listDocs` | List documents in a collection | [`src/components/table.js`](https://github.com/junobuild/create-juno/blob/main/templates/vanilla-js-example/src/components/table.js) | [List documents](/docs/build/datastore/development.md#list-documents) |
| `setDoc` | Create or update a document | [`src/components/modal.js`](https://github.com/junobuild/create-juno/blob/main/templates/vanilla-js-example/src/components/modal.js) | [Add a document](/docs/build/datastore/development.md#add-a-document) |
| `deleteDoc` | Delete a document | [`src/components/delete.js`](https://github.com/junobuild/create-juno/blob/main/templates/vanilla-js-example/src/components/delete.js) | [Delete a document](/docs/build/datastore/development.md#delete-a-document) |
| `uploadFile` | Upload a file to storage | [`src/components/modal.js`](https://github.com/junobuild/create-juno/blob/main/templates/vanilla-js-example/src/components/modal.js) | [Upload file](/docs/build/storage/development.md#upload-file) |
| `deleteAsset` | Delete a file from storage | [`src/components/delete.js`](https://github.com/junobuild/create-juno/blob/main/templates/vanilla-js-example/src/components/delete.js) | [Delete asset](/docs/build/storage/development.md#delete-asset) |

# Vue Example

This project is a note-taking app template built with **Vue**, **TypeScript**, and **Tailwind CSS**, designed to demonstrate integration with Juno for app development. It showcases authentication, data storage, and file storage using Juno's Satellite container.

You can scaffold it using the following command, or browse the source code:

```
npm create juno@latest -- --template vue-example
```

Source: [github.com/junobuild/create-juno/templates/vue-example](https://github.com/junobuild/create-juno/tree/main/templates/vue-example)

---

## Folder Structure

```
vue-example/â”œâ”€â”€ public/                # Static assetsâ”œâ”€â”€ src/â”‚   â”œâ”€â”€ components/        # Vue UI components (Auth, Table, Modal, Banner, etc.)â”‚   â”œâ”€â”€ stores/            # Pinia stores for auth, etc.â”‚   â”œâ”€â”€ types/             # TypeScript types (e.g., note.ts)â”‚   â”œâ”€â”€ App.vue            # Main app componentâ”‚   â”œâ”€â”€ main.ts            # Vue entry pointâ”œâ”€â”€ juno.config.ts         # Juno Satellite configurationâ”œâ”€â”€ package.json           # Project dependencies and scriptsâ”œâ”€â”€ vite.config.ts         # Vite build configurationâ”œâ”€â”€ README.md              # User-facing documentationâ””â”€â”€ ...                    # Other config and build files
```

---

## Key Features

*   **Juno Integration**: Uses Juno's Satellite for authentication, Datastore, and Storage.
*   **Authentication**: Login/logout flow.
*   **Notes Collection**: Users can create, view, and delete notes (text, with optional file URL).
*   **Images Collection**: Supports file storage for images.
*   **Responsive UI**: Built with Tailwind CSS for modern styling.
*   **Banner**: Warns if the Satellite is not configured for local development.

---

## Main Components

*   **src/App.vue**: Main app component, initializes Juno Satellite, wraps content in authentication.
*   **components/**: Contains UI and logic for authentication, notes table, modal, banner, etc.
*   **stores/auth.store.ts**: Pinia store for authentication state.
*   **types/note.ts**: TypeScript interface for notes.

---

## Data Structure

*   **Note** (`src/types/note.ts`):

```
export interface Note {  text: string;  url?: string;}
```

---

## How to Run

. **Install dependencies**:

```
npm install
```

NaN. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

3. **Create a Satellite** for local dev:

*   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
*   Update `juno.config.ts` with your Satellite ID.

4.  **Create required collections**:

*   `notes` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)
*   `images` in Storage: [http://localhost:5866/storage](http://localhost:5866/storage)

5.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

---

## Juno-Specific Configuration

*   **juno.config.ts**: Defines Satellite IDs for development/production, build source, and predeploy steps. See the [Configuration reference](/docs/reference/configuration.md) for details.
*   **vite.config.ts**: Registers the `juno` plugin to inject environment variables automatically. See the [Vite Plugin reference](/docs/reference/plugins.md#vite-plugin) for more information.

---

## Production Deployment

*   Create a Satellite on the [Juno Console](https://console.juno.build) for mainnet.
*   Update with the production Satellite ID.
*   Build and deploy:

```
npm run buildjuno hosting deploy
```

---

## Notes

*   The app is intended as a starting point for Juno-based projects.
*   All logic is in TypeScript and Vue components/stores.
*   The app is fully client-side (Server Side Rendering is not supported yet) and interacts with Juno via the Satellite container.

---

## Juno SDK Used

The following functions from `@junobuild/core` are used in this example:

| Function | Purpose/Description | Where Used (File/Component) | Juno Docs/Source Reference |
| --- | --- | --- | --- |
| `initSatellite` | Initialize Juno Satellite container | [`src/App.vue`](https://github.com/junobuild/create-juno/blob/main/templates/vue-example/src/App.vue) | [Initialization](/docs/setup-the-sdk.md#initialization) |
| `onAuthStateChange` | Subscribe to auth state changes | [`src/stores/auth.store.ts`](https://github.com/junobuild/create-juno/blob/main/templates/vue-example/src/stores/auth.store.ts) | [Listening to Auth Changes](/docs/build/authentication/utilities.md#listening-to-auth-changes) |
| `signIn` | Sign in user | [`src/components/Login.vue`](https://github.com/junobuild/create-juno/blob/main/templates/vue-example/src/components/Login.vue) | [Sign-in](/docs/build/authentication/internet-identity.md#sign-in) |
| `signOut` | Sign out user | [`src/components/Logout.vue`](https://github.com/junobuild/create-juno/blob/main/templates/vue-example/src/components/Logout.vue) | [Sign-out](/docs/build/authentication/utilities.md#sign-out) |
| `listDocs` | List documents in a collection | [`src/components/Table.vue`](https://github.com/junobuild/create-juno/blob/main/templates/vue-example/src/components/Table.vue) | [List documents](/docs/build/datastore/development.md#list-documents) |
| `setDoc` | Create or update a document | [`src/components/Modal.vue`](https://github.com/junobuild/create-juno/blob/main/templates/vue-example/src/components/Modal.vue) | [Add a document](/docs/build/datastore/development.md#add-a-document) |
| `deleteDoc` | Delete a document | [`src/components/Delete.vue`](https://github.com/junobuild/create-juno/blob/main/templates/vue-example/src/components/Delete.vue) | [Delete a document](/docs/build/datastore/development.md#delete-a-document) |
| `uploadFile` | Upload a file to storage | [`src/components/Modal.vue`](https://github.com/junobuild/create-juno/blob/main/templates/vue-example/src/components/Modal.vue) | [Upload file](/docs/build/storage/development.md#upload-file) |
| `deleteAsset` | Delete a file from storage | [`src/components/Delete.vue`](https://github.com/junobuild/create-juno/blob/main/templates/vue-example/src/components/Delete.vue) | [Delete asset](/docs/build/storage/development.md#delete-asset) |

# Rust

Examples of writing serverless functions in Rust for Juno. Includes patterns like custom assertions, data manipulation and calls.

[## ðŸ“„ï¸ Assertion

An example demonstrating how to write custom assertions in Rust for Juno serverless functions.](/docs/examples/functions/rust/assertion.md)

[## ðŸ“„ï¸ Mutation

An example demonstrating how to modify and re-save documents in Juno Satellites using Rust hooks.](/docs/examples/functions/rust/mutating-docs.md)

[## ðŸ“„ï¸ Asset Generation

An example showing how to dynamically generate and store assets (like JSON) in Storage using Rust in Juno Satellites.](/docs/examples/functions/rust/generating-assets.md)

[## ðŸ“„ï¸ Canister Calls

An example showing how to call external canisters (e.g., ICRC ledger) from a serverless function written in Rust using Juno Satellites.](/docs/examples/functions/rust/canister-calls.md)

# TypeScript

Examples of writing serverless functions in TypeScript for Juno. Includes patterns like custom assertions, data manipulation and calls.

[## ðŸ“„ï¸ Assertion

An example demonstrating how to write custom assertions in TypeScript for Juno serverless functions.](/docs/examples/functions/typescript/assertion.md)

[## ðŸ“„ï¸ Mutation

An example demonstrating how to modify and re-save documents in Juno Satellites using TypeScript hooks.](/docs/examples/functions/typescript/mutating-docs.md)

[## ðŸ“„ï¸ Canister Calls

An example showing how to call external canisters (e.g., ICRC ledger) from a serverless function written in TypeScript using Juno Satellites.](/docs/examples/functions/typescript/canister-calls.md)

# Rust Assertion Example

This example demonstrates how to write a **custom assertion** in **Rust** for a Juno **serverless function**. It shows how to intercept and validate data operationsâ€”such as rejecting specific contentâ€”before it's written to the datastore.

The project includes a minimal frontend to help trigger and test the logic, but the primary focus is the backend assertion.

You can browse the source code here: [github.com/junobuild/examples/tree/main/functions/rust/assertions](https://github.com/junobuild/examples/tree/main/functions/rust/assertions)

---

## Folder Structure

```
rust/assertions/â”œâ”€â”€ src/â”‚   â”œâ”€â”€ satellite/           # Rust Satellite serverless functionâ”‚   â”‚   â”œâ”€â”€ src/â”‚   â”‚   â”‚   â””â”€â”€ lib.rs       # Main Rust logic for Satelliteâ”‚   â”‚   â”œâ”€â”€ satellite.did    # Candid interface definitionâ”‚   â”‚   â””â”€â”€ Cargo.toml       # Rust package configâ”œâ”€â”€ src/components/          # Minimal frontend React componentsâ”œâ”€â”€ juno.config.ts           # Juno Satellite configurationâ”œâ”€â”€ package.json             # Frontend dependenciesâ””â”€â”€ ...
```

---

## Key Features

*   **Custom Assertions in Rust**: Demonstrates how to reject or validate data before it's saved, using Rust serverless functions.
*   **Serverless Integration**: Runs as a Satellite function and integrates with Juno's datastore and authentication system.
*   **Minimal UI for Testing**: A simple frontend is included to test and demonstrate the assertion logic in action.

---

## Main Backend Components

*   **src/satellite/src/lib.rs**: The core Rust logic for the Satellite serverless function. Implements the custom assertions (e.g., only allow certain valid inputs, etc.).
*   **src/satellite/Cargo.toml**: Rust package configuration for the Satellite function.

---

## Example: Custom Assertion in Rust

Hereâ€™s the actual Rust logic from `lib.rs`:

```
// This example defines a custom assertion in a Juno Satellite using Rust.// It checks if a document being saved to the "notes" collection contains the word "hello".// If it does, the assertion rejects the operation and logs a message.use ic_cdk::print;use junobuild_macros::assert_set_doc;use junobuild_satellite::{include_satellite, AssertSetDocContext};use junobuild_utils::decode_doc_data;use serde::{Deserialize, Serialize};#[derive(Serialize, Deserialize)]struct Note {    text: String,    url: Option<String>,}#[assert_set_doc(collections = ["notes"])]fn assert_set_doc(context: AssertSetDocContext) -> Result<(), String> {    let note = decode_doc_data::<Note>(&context.data.data.proposed.data)?;    if note.text.to_lowercase().contains("hello") {        print(format!("âŒ Rejected note containing 'hello': {}", note.text));        return Err("The note should not contain the keyword 'hello'.".to_string());    }    print(format!("âœ… Note accepted: {}", note.text));    Ok(())}include_satellite!();
```

**Explanation:**

*   Defines a `Note` struct with `text` and optional `url` fields. Similar as the fields used in the frontend.
*   Uses the `#[assert_set_doc]` macro to create a custom assertion for the `notes` collection.
*   When a note is created or updated, the assertion checks if the note's text contains the word "hello" (case-insensitive).
*   If it does, the note is rejected and an error message is returned; otherwise, the note is accepted.
*   Prints a message to the log for both accepted and rejected notes.
*   `include_satellite!();` brings in the necessary boilerplate for the Juno Satellite runtime.

---

## How to Run

1.  **Clone the repo**:

```
git clone https://github.com/junobuild/examplescd rust/assertions
```

2. **Install dependencies**:

```
npm install
```

3. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

4. **Create a Satellite** for local dev:

*   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
*   Update `juno.config.ts` with your Satellite ID.

5.  **Create required collections**:

*   `notes` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)
*   `images` in Storage: [http://localhost:5866/storage](http://localhost:5866/storage)

6.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

7.  **Build the serverless functions** (in a separate terminal):

```
juno functions build
```

The emulator will automatically upgrade your Satellite and live reload the changes.

---

## Juno-Specific Configuration

*   **juno.config.ts**: Defines Satellite IDs for development/production, build source, and predeploy steps. See the [Configuration reference](/docs/reference/configuration.md) for details.
*   **vite.config.ts**: Registers the `juno` plugin to inject environment variables automatically. See the [Vite Plugin reference](/docs/reference/plugins.md#vite-plugin) for more information.

---

## Production Deployment

*   Create a Satellite on the [Juno Console](https://console.juno.build) for mainnet.
*   Update `juno.config.ts` with the production Satellite ID.
*   Build and deploy the frontend:

```
npm run buildjuno hosting deploy
```

*   Build and upgrade the serverless functions:

```
juno functions buildjuno functions upgrade
```

---

## Notes

*   This example focuses on the Rust serverless function; the frontend is intentionally minimal and only included for demonstration purposes.
*   Use this project as a starting point for writing custom assertions and backend logic in Rust with Juno.

---

## Real-World Example

Want to see how assertions and serverless logic are used in a live project?

Check out [proposals.network](https://proposals.network), an open-source app built with Juno:

*   GitHub: [github.com/peterpeterparker/proposals.network](https://github.com/peterpeterparker/proposals.network)
*   Example logic: [src/satellite/src/lib.rs](https://github.com/peterpeterparker/proposals.network/blob/main/src/satellite/src/lib.rs)

This app uses:

*   `#[on_delete_doc]` and `#[assert_delete_doc]` to validate and clean up related documents and assets
*   Shared helper modules like `assert`, `delete`, and `types` to keep logic organized
*   A real-world pattern of chaining asset/document deletions with assertions

Itâ€™s a great reference for more advanced setups and multi-collection coordination.

---

## References

*   [Serverless Functions Guide](/docs/guides/rust.md)
*   [Functions Development](/docs/build/functions.md)
*   [Rust SDK Reference](/docs/reference/functions/rust/sdk.md)
*   [Rust Utils Reference](/docs/reference/functions/rust/utils.md)
*   [Run Local Development](/docs/guides/local-development.md)
*   [CLI Reference](/docs/reference/cli.md)
*   [Configuration Reference](/docs/reference/configuration.md)
*   [Datastore Collections](/docs/build/datastore/collections.md)

---

## Crate Docs

These crates are used to build and extend serverless functions in Rust with Juno:

*   [junobuild-satellite](https://docs.rs/junobuild-satellite): Core features and runtime for building a Satellite in Rust, including hooks, assertions, and datastore integration.
*   [junobuild-macros](https://docs.rs/junobuild-macros): Procedural macros for declaratively attaching hooks and assertions.
*   [junobuild-utils](https://docs.rs/junobuild-utils): Utility helpers for working with documents, including data encoding, decoding, and assertion context handling.
*   [junobuild-shared](https://docs.rs/junobuild-shared): Shared types and helpers for Juno projects. Used by all containers including the Console.
*   [junobuild-storage](https://docs.rs/junobuild-storage): Storage helpers for working with assets and HTTP headers in Juno.

# Making Canister Calls in Rust Serverless Functions

This example demonstrates how to use **Rust serverless functions** to perform canister calls (such as `transfer_from` on the ICP ledger) in response to Datastore events in your Juno **Satellite**.

When a document is added to the `request` collection, a serverless function is triggered to:

*   Check if the user has enough ICP in their wallet
*   Transfer ICP from the user's wallet to the Satellite using the ICRC ledger's `transfer_from` method
*   Mark the request as `processed` if the transfer succeeds

This pattern is useful for building workflows that require asset transfers or other canister calls in response to user actions.

You can browse the source code here: [github.com/junobuild/examples/tree/main/functions/rust/calls](https://github.com/junobuild/examples/tree/main/functions/rust/calls)

---

## Folder Structure

```
rust/calls/â”œâ”€â”€ src/â”‚   â”œâ”€â”€ satellite/           # Rust Satellite serverless functionâ”‚   â”‚   â”œâ”€â”€ src/â”‚   â”‚   â”‚   â”œâ”€â”€ lib.rs       # Main Rust logic for Satelliteâ”‚   â”‚   â”‚   â”œâ”€â”€ services.rs  # Helper logic for balance, transfer, statusâ”‚   â”‚   â”‚   â”œâ”€â”€ types.rs     # Data model for requestsâ”‚   â”‚   â”‚   â”œâ”€â”€ ledger_icrc.rs # Ledger helper functionsâ”‚   â”‚   â”‚   â””â”€â”€ ...â”‚   â”‚   â”œâ”€â”€ satellite.did    # Candid interface definitionâ”‚   â”‚   â””â”€â”€ Cargo.toml       # Rust package configâ”‚   â”œâ”€â”€ declarations/        # TypeScript declarations for Satelliteâ”‚   â”œâ”€â”€ components/          # React frontend componentsâ”‚   â”œâ”€â”€ services/            # Frontend service logicâ”‚   â”œâ”€â”€ types/               # Frontend type definitionsâ”‚   â”œâ”€â”€ main.tsx             # Frontend entryâ”‚   â””â”€â”€ ...â”œâ”€â”€ juno.config.ts           # Juno Satellite configurationâ”œâ”€â”€ package.json             # Frontend dependenciesâ””â”€â”€
```

---

## Key Features

*   **Serverless Canister Calls**: Demonstrates how to perform ICRC ledger calls (e.g., `transfer_from`) from Rust serverless functions.
*   **Atomic Request Processing**: Ensures that request status is only updated if the transfer succeeds.
*   **Wallet Balance Checks**: Fails early if the user does not have enough ICP.
*   **Minimal React UI**: A simple React frontend is included to test and demonstrate the logic.

---

## Main Backend Components

*   **src/satellite/src/lib.rs**: The entry point for the Satellite serverless function. Triggers the canister call and updates request status on document set.
*   **src/satellite/src/services.rs**: Helper logic for checking wallet balance, performing the transfer, and updating request status.
*   **src/satellite/src/types.rs**: Data model for requests and status.
*   **src/satellite/Cargo.toml**: Rust package configuration for the Satellite function.

---

## Example: Canister Call on Document Set

Hereâ€™s the actual Rust logic from `lib.rs` and `services.rs`:

```
// src/satellite/src/lib.rsmod env;mod ledger_icrc;mod services;mod types;mod utils;use crate::services::{assert_wallet_balance, set_request_processed, transfer_icp_from_wallet};use crate::types::RequestData;use crate::utils::icp_ledger_id;use ic_cdk::id;use icrc_ledger_types::icrc1::account::Account;use junobuild_macros::on_set_doc;use junobuild_satellite::{include_satellite, OnSetDocContext};use junobuild_utils::decode_doc_data;// Triggered when a new document is set in the "request" collection#[on_set_doc(collections = ["request"])]async fn on_set_doc(context: OnSetDocContext) -> Result<(), String> {    // Init data    let data: RequestData = decode_doc_data(&context.data.data.after.data)?;    let request_amount = data.amount.value;    let fee = data.fee.as_ref().map(|fee| fee.value);    let ledger_id = icp_ledger_id()?;    let from_account: Account = Account::from(context.caller);    // Check current account balance    assert_wallet_balance(&ledger_id, &from_account, &request_amount, &fee).await?;    // Update request status to processed (atomic with transfer)    set_request_processed(context.data.key, &data, &context.data.data.after.version)?;    // Transfer from wallet to satellite    let to_account: Account = Account::from(id());    transfer_icp_from_wallet(        &ledger_id,        &from_account,        &to_account,        &request_amount,        &fee,    )    .await?;    Ok(())}include_satellite!();
```

```
// src/satellite/src/services.rs/// Asserts that the given account has enough balance to cover the amount and fee.pub async fn assert_wallet_balance(    ledger_id: &Principal,    from_account: &Account,    amount: &u64,    fee: &Option<u64>,) -> Result<(), String> {    let balance = icrc_balance_of(&ledger_id, &from_account).await?;    let total = amount.saturating_add(fee.unwrap_or(10_000u64));    if balance < total {        return Err(format!("Balance {} is smaller than {}", balance, total));    }    Ok(())}/// Transfers ICP from one account to another using `icrc2_transfer_from`.pub async fn transfer_icp_from_wallet(    ledger_id: &Principal,    from_account: &Account,    to_account: &Account,    amount: &u64,    fee: &Option<u64>,) -> Result<(), String> {    let result = icrc_transfer_from(        &ledger_id,        &from_account,        &to_account,        &Nat::from(amount.clone()),        &fee.map(|fee| Nat::from(fee)),    )    .await    .map_err(|e| format!("Failed to call ICRC ledger icrc_transfer_from: {:?}", e))    .and_then(|result| {        result.map_err(|e| format!("Failed to execute the transfer from: {:?}", e))    })?;    print(format!("Result of the transfer from is {:?}", result));    Ok(())}/// Updates the request document status to `Processed`.pub fn set_request_processed(    key: String,    original_data: &RequestData,    original_version: &Option<u64>,) -> Result<(), String> {    let update_data: RequestData = RequestData {        status: RequestStatus::Processed,        ..original_data.clone()    };    let data = encode_doc_data(&update_data)?;    let doc: SetDoc = SetDoc {        data,        description: None,        version: original_version.clone(),    };    let _ = set_doc_store(id(), "request".to_string(), key, doc)?;    Ok(())}
```

**Explanation:**

*   When a request is submitted, the `on_set_doc` hook is triggered for the `request` collection.
*   The function checks the user's wallet balance, updates the request status, and performs the ICP transfer atomically.
*   If any step fails, the entire operation is reverted.
*   The frontend can monitor request status and balances via the exposed APIs.

---

## How to Run

1.  **Clone the repo**:

```
git clone https://github.com/junobuild/examplescd rust/calls
```

2. **Install dependencies**:

```
npm install
```

3. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

4. **Create a Satellite** for local dev:

*   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
*   Update `juno.config.ts` with your Satellite ID.

5.  **Create required collections**:

*   `request` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)

6.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

7.  **Build the serverless functions** (in a separate terminal):

```
juno functions build
```

The emulator will automatically upgrade your Satellite and live reload the changes.

---

## Juno-Specific Configuration

*   **juno.config.ts**: Defines Satellite IDs for development/production, build source, and predeploy steps. See the [Configuration reference](/docs/reference/configuration.md) for details.
*   **vite.config.ts**: Registers the `juno` plugin to inject environment variables automatically. See the [Vite Plugin reference](/docs/reference/plugins.md#vite-plugin) for more information.

---

## Production Deployment

*   Create a Satellite on the [Juno Console](https://console.juno.build) for mainnet.
*   Update `juno.config.ts` with the production Satellite ID.
*   Build and deploy the frontend:

```
npm run buildjuno hosting deploy
```

*   Build and upgrade the serverless functions:

```
juno functions buildjuno functions upgrade
```

---

## Notes

*   This example focuses on the Rust serverless function and canister call integration. The frontend is intentionally minimal and included only for demonstration.
*   Use this project as a starting point for workflows that require on-chain asset transfers or canister calls in response to user actions.

## Real-World Example

Want to see how assertions and serverless logic are used in a live project?

Check out [proposals.network](https://proposals.network), an open-source app built with Juno:

*   GitHub: [github.com/peterpeterparker/proposals.network](https://github.com/peterpeterparker/proposals.network)
*   Example logic: [src/satellite/src/lib.rs](https://github.com/peterpeterparker/proposals.network/blob/main/src/satellite/src/lib.rs)

This app uses:

*   `#[on_delete_doc]` and `#[assert_delete_doc]` to validate and clean up related documents and assets
*   Shared helper modules like `assert`, `delete`, and `types` to keep logic organized
*   A real-world pattern of chaining asset/document deletions with assertions

Itâ€™s a great reference for more advanced setups and multi-collection coordination.

---

## References

*   [Serverless Functions Guide](/docs/guides/rust.md)
*   [Functions Development](/docs/build/functions.md)
*   [Rust SDK Reference](/docs/reference/functions/rust/sdk.md)
*   [Rust Utils Reference](/docs/reference/functions/rust/utils.md)
*   [Run Local Development](/docs/guides/local-development.md)
*   [CLI Reference](/docs/reference/cli.md)
*   [Configuration Reference](/docs/reference/configuration.md)
*   [Datastore Collections](/docs/build/datastore/collections.md)

---

## Crate Docs

These crates are used to build and extend serverless functions in Rust with Juno:

*   [junobuild-satellite](https://docs.rs/junobuild-satellite): Core features and runtime for building a Satellite in Rust, including hooks, assertions, and datastore integration.
*   [junobuild-macros](https://docs.rs/junobuild-macros): Procedural macros for declaratively attaching hooks and assertions.
*   [junobuild-utils](https://docs.rs/junobuild-utils): Utility helpers for working with documents, including data encoding, decoding, and assertion context handling.
*   [junobuild-shared](https://docs.rs/junobuild-shared): Shared types and helpers for Juno projects. Used by all containers including the Console.
*   [junobuild-storage](https://docs.rs/junobuild-storage): Storage helpers for working with assets and HTTP headers in Juno.

*   [icrc-ledger-types](https://docs.rs/icrc-ledger-types): Types for interacting with the ICRC ledger standard.
    
*   [ic-cdk](https://docs.rs/ic-cdk): Internet Computer canister development kit for Rust.

# Generating Assets with Rust Serverless Functions

This example demonstrates how to use **Rust serverless functions** to dynamically generate and store assets in **Juno Storage** from a **Satellite**. In this example, the generated assets are JSON files.

Each time a note is added through the frontend, the Satellite saves the note as an individual JSON file and updates a list of all notes as another JSON file. This pattern is useful for exposing structured, queryable data as static assets â€” consumable by your frontend or external services.

You can browse the source code here: [github.com/junobuild/examples/tree/main/functions/rust/json](https://github.com/junobuild/examples/tree/main/functions/rust/json)

---

## Folder Structure

```
rust/json/â”œâ”€â”€ src/â”‚   â”œâ”€â”€ satellite/           # Rust Satellite serverless functionâ”‚   â”‚   â”œâ”€â”€ src/â”‚   â”‚   â”‚   â”œâ”€â”€ lib.rs       # Main Rust logic for Satelliteâ”‚   â”‚   â”‚   â””â”€â”€ generators.rs# Helper logic for JSON generation/storageâ”‚   â”‚   â”œâ”€â”€ satellite.did    # Candid interface definitionâ”‚   â”‚   â””â”€â”€ Cargo.toml       # Rust package configâ”‚   â”œâ”€â”€ declarations/        # TypeScript declarations for Satelliteâ”‚   â”œâ”€â”€ lib/                 # Svelte frontend components, stores, typesâ”‚   â”œâ”€â”€ routes/              # SvelteKit route filesâ”‚   â”œâ”€â”€ app.html             # Svelte app entryâ”‚   â””â”€â”€ app.css              # Stylesâ”œâ”€â”€ juno.config.ts           # Juno Satellite configurationâ”œâ”€â”€ package.json             # Frontend dependenciesâ””â”€â”€ ...
```

---

## Key Features

*   **Serverless JSON Generation**: Demonstrates how to generate and store JSON files in Storage from Rust serverless functions.
*   **Automatic List Updates**: Each note addition updates both the individual note JSON and a list of all notes as JSON.
*   **Integration with Juno Storage**: Uses Juno's Storage API to expose JSON assets on the web.
*   **Minimal SvelteKit UI**: A simple SvelteKit frontend is included to test and demonstrate the logic.

---

## Main Backend Components

*   **src/satellite/src/lib.rs**: The entry point for the Satellite serverless function. Triggers JSON generation and list update on document set.
*   **src/satellite/src/generators.rs**: Helper logic for encoding notes and lists as JSON and storing them as assets.
*   **src/satellite/Cargo.toml**: Rust package configuration for the Satellite function.

---

## Example: Generating and Storing JSON

Hereâ€™s the actual Rust logic from `lib.rs` and `generators.rs`:

```
// src/satellite/src/lib.rsmod generators;use crate::generators::{generate_list_of_notes, generate_note};use junobuild_macros::on_set_doc;use junobuild_satellite::{include_satellite, OnSetDocContext};/// Hook triggered whenever a document is set (e.g., added or updated)./// This example:/// - Stores the updated document as an individual JSON file in Storage/// - Updates a list of all note filenames as a separate JSON file#[on_set_doc]async fn on_set_doc(context: OnSetDocContext) -> Result<(), String> {    ic_cdk::print("Let's go!");    // Save the current note as a JSON asset    generate_note(&context.data.key, &context.data.data.after)?;    // Regenerate the list of notes as a JSON array    generate_list_of_notes()?;    Ok(())}// Boilerplate macro to include the all Satellite runtimeinclude_satellite!();
```

```
// src/satellite/src/generators.rsuse junobuild_satellite::{list_assets_store, set_asset_handler, Doc};use junobuild_shared::types::core::Key;use junobuild_shared::types::list::ListParams;use junobuild_storage::http::types::HeaderField;use junobuild_storage::types::store::AssetKey;use junobuild_utils::{decode_doc_data, encode_doc_data_to_string};use serde::{Deserialize, Serialize};/// Represents the expected shape of a note stored in the Datastore#[derive(Serialize, Deserialize)]struct Note {    text: String,    url: Option<String>,}/// Encodes a note document as JSON and stores it as a `.json` file in Storagepub fn generate_note(key: &Key, doc: &Doc) -> Result<(), String> {    let note: Note = decode_doc_data(&doc.data)?;    let json = encode_doc_data_to_string(&note)?;    let name = format!("{}.json", key);    insert_asset(&name, &json)}const STORAGE_COLLECTION: &str = "json";/// Lists all assets in the `json` collection and stores their filenames/// in a `notes.json` file â€” a JSON array of all note filenamespub fn generate_list_of_notes() -> Result<(), String> {    let params: ListParams = ListParams {        matcher: None,        paginate: None,        order: None,        owner: None,    };    let result = list_assets_store(ic_cdk::id(), STORAGE_COLLECTION, &params)?;    // Extract the full paths of all assets in the collection    let list_of_keys: Vec<String> = result        .items        .iter()        .map(|(_, asset)| asset.key.full_path.clone())        .collect();    let json = encode_doc_data_to_string(&list_of_keys)?;    let name = "notes.json".to_string();    insert_asset(&name, &json)?;    Ok(())}/// Stores a given string as an asset in the `json` collectionfn insert_asset(name: &String, json: &String) -> Result<(), String> {    ic_cdk::print(format!("Json: {} {}", name, json));    let full_path = format!("/{}/{}", STORAGE_COLLECTION, name);    let key: AssetKey = AssetKey {        name: name.clone(),        full_path: full_path.clone(),        token: None,        collection: STORAGE_COLLECTION.to_string(),        owner: ic_cdk::id(),        description: None,    };    // Set appropriate headers for serving JSON    let headers = vec![HeaderField(        "content-type".to_string(),        "application/json".to_string(),    )];    // Upload asset to Juno Storage    set_asset_handler(&key, &json.as_bytes().to_vec(), &headers)?;    ic_cdk::print(format!(        "Asset saved in Storage: http://{}.localhost:5987{}",        ic_cdk::id(),        full_path    ));    Ok(())}
```

**Explanation:**

*   When a note is added or updated, the `on_set_doc` hook is triggered.
*   The note is encoded as JSON and stored as an asset in the `json` collection.
*   A list of all note asset paths is also generated and stored as `notes.json`.
*   These JSON assets are accessible via the Storage API and can be fetched by the frontend or other clients.

---

## How to Run

1.  **Clone the repo**:

```
git clone https://github.com/junobuild/examplescd rust/hooks
```

2. **Install dependencies**:

```
npm install
```

3. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

4. **Create a Satellite** for local dev:

*   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
*   Update `juno.config.ts` with your Satellite ID.

5.  **Create required collections**:

*   `demo` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)
*   `json` in Storage: [http://localhost:5866/storage](http://localhost:5866/storage)

6.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

7.  **Build the serverless functions** (in a separate terminal):

```
juno functions build
```

The emulator will automatically upgrade your Satellite and live reload the changes.

---

## Juno-Specific Configuration

*   **juno.config.ts**: Defines Satellite IDs for development/production, build source, and predeploy steps. See the [Configuration reference](/docs/reference/configuration.md) for details.
*   **vite.config.ts**: Registers the `juno` plugin to inject environment variables automatically. See the [Vite Plugin reference](/docs/reference/plugins.md#vite-plugin) for more information.

---

## Production Deployment

*   Create a Satellite on the [Juno Console](https://console.juno.build) for mainnet.
*   Update `juno.config.ts` with the production Satellite ID.
*   Build and deploy the frontend:

```
npm run buildjuno hosting deploy
```

*   Build and upgrade the serverless functions:

```
juno functions buildjuno functions upgrade
```

---

## Notes

*   This example focuses on the Rust serverless function. The frontend is intentionally minimal and included only for demonstration.
*   Use this project as a starting point for generate dynamic assets using Juno and Rust.

---

## References

*   [Serverless Functions Guide](/docs/guides/rust.md)
*   [Functions Development](/docs/build/functions.md)
*   [Rust SDK Reference](/docs/reference/functions/rust/sdk.md)
*   [Rust Utils Reference](/docs/reference/functions/rust/utils.md)
*   [Run Local Development](/docs/guides/local-development.md)
*   [CLI Reference](/docs/reference/cli.md)
*   [Configuration Reference](/docs/reference/configuration.md)
*   [Datastore Collections](/docs/build/datastore/collections.md)

---

## Crate Docs

These crates are used to build and extend serverless functions in Rust with Juno:

*   [junobuild-satellite](https://docs.rs/junobuild-satellite): Core features and runtime for building a Satellite in Rust, including hooks, assertions, and datastore integration.
*   [junobuild-macros](https://docs.rs/junobuild-macros): Procedural macros for declaratively attaching hooks and assertions.
*   [junobuild-utils](https://docs.rs/junobuild-utils): Utility helpers for working with documents, including data encoding, decoding, and assertion context handling.
*   [junobuild-shared](https://docs.rs/junobuild-shared): Shared types and helpers for Juno projects. Used by all containers including the Console.
*   [junobuild-storage](https://docs.rs/junobuild-storage): Storage helpers for working with assets and HTTP headers in Juno.

# Mutating Documents with Rust Hooks

This example demonstrates how to use **hooks in Rust** to modify documents automatically when they're created or updated in your Juno **Satellite**.

Hooks let you react to events like document creation, deletion, or asset uploads â€” and run custom backend logic in response.

You can browse the source code here: [github.com/junobuild/examples/tree/main/functions/rust/hooks](https://github.com/junobuild/examples/tree/main/functions/rust/hooks)

---

## Folder Structure

```
rust/hooks/â”œâ”€â”€ src/â”‚   â”œâ”€â”€ satellite/           # Rust Satellite serverless functionâ”‚   â”‚   â”œâ”€â”€ src/â”‚   â”‚   â”‚   â””â”€â”€ lib.rs       # Main Rust logic for Satelliteâ”‚   â”‚   â”œâ”€â”€ satellite.did    # Candid interface definitionâ”‚   â”‚   â””â”€â”€ Cargo.toml       # Rust package configâ”‚   â”œâ”€â”€ declarations/        # TypeScript declarations for Satelliteâ”‚   â”œâ”€â”€ admin.ts             # Frontend admin logicâ”‚   â”œâ”€â”€ doc.ts               # Frontend doc logicâ”‚   â”œâ”€â”€ main.ts              # Frontend entry pointâ”‚   â”œâ”€â”€ storage.ts           # Frontend storage logicâ”‚   â””â”€â”€ style.css            # Frontend stylesâ”œâ”€â”€ juno.config.ts           # Juno Satellite configurationâ”œâ”€â”€ package.json             # Frontend dependenciesâ””â”€â”€ ...
```

---

## Key Features

*   **Serverless Hooks in Rust**: Demonstrates how to react to data and asset operations using hooks in Rust serverless functions.
*   **Multiple Hook Types**: Includes hooks for document set, set-many, delete, and asset upload operations.
*   **Serverless Integration**: Runs as a Satellite function and integrates with Juno's datastore and authentication system.
*   **Minimal UI for Testing**: A simple frontend is included to test and demonstrate the hook logic in action.

---

## Main Backend Components

*   **src/satellite/src/lib.rs**: The core Rust logic for the Satellite serverless function. Implements hooks for various operations (set, set-many, delete, upload).
*   **src/satellite/Cargo.toml**: Rust package configuration for the Satellite function.

---

## Example: Mutating Documents

Hereâ€™s the actual Rust logic from `lib.rs`:

```
use ic_cdk::print;use junobuild_macros::{on_delete_doc, on_set_doc, on_set_many_docs, on_upload_asset};use junobuild_satellite::{    include_satellite, set_doc_store, OnDeleteDocContext, OnSetDocContext, OnSetManyDocsContext,    OnUploadAssetContext, SetDoc,};use junobuild_utils::{decode_doc_data, encode_doc_data};use junobuild_utils::{DocDataBigInt, DocDataPrincipal};use serde::{Deserialize, Serialize};/// Example struct used to demonstrate decode/edit/store flow.#[derive(Serialize, Deserialize)]struct Person {    yolo: bool,    hello: String,    principal: DocDataPrincipal,    value: DocDataBigInt,}// Hook that runs when a document is set in the "demo" collection#[on_set_doc(collections = ["demo"])]async fn on_set_doc(context: OnSetDocContext) -> Result<(), String> {    // Decode the document into our Person struct    let mut data: Person = decode_doc_data(&context.data.data.after.data)?;    // Log some values for debugging    print(format!("[on_set_doc] Caller: {}", context.caller.to_text()));    print(format!("[on_set_doc] Collection: {}", context.data.collection));    print(format!("[on_set_doc] Data: {} {}", data.principal.value, data.value.value));    // Modify the document before storing it again    data.hello = format!("{} checked", data.hello);    data.yolo = false;    // Encode and re-store the updated document    let encode_data = encode_doc_data(&data)?;    let doc: SetDoc = SetDoc {        data: encode_data,        description: context.data.data.after.description,        version: context.data.data.after.version,    };    set_doc_store(        context.caller,        context.data.collection,        context.data.key,        doc,    )?;    Ok(())}include_satellite!();
```

**Explanation:**

*   Defines a `Person` struct with fields for demo purposes.
*   Uses the `#[on_set_doc]` macro to run logic whenever a document is set in the `demo` collection. Updates the document and saves it back.
*   `include_satellite!();` brings in the necessary boilerplate for the Juno Satellite runtime.

---

## How to Run

1.  **Clone the repo**:

```
git clone https://github.com/junobuild/examplescd rust/hooks
```

2. **Install dependencies**:

```
npm install
```

3. **Start Juno local emulator**:

**Important:**

Requires the Juno CLI to be available `npm i -g @junobuild/cli`

```
juno emulator start
```

4. **Create a Satellite** for local dev:

*   Visit [http://localhost:5866](http://localhost:5866) and follow the instructions.
*   Update `juno.config.ts` with your Satellite ID.

5.  **Create required collections**:

*   `demo` in Datastore: [http://localhost:5866/datastore](http://localhost:5866/datastore)
*   `images` in Storage: [http://localhost:5866/storage](http://localhost:5866/storage)

6.  **Start the frontend dev server** (in a separate terminal):

```
npm run dev
```

7.  **Build the serverless functions** (in a separate terminal):

```
juno functions build
```

The emulator will automatically upgrade your Satelli